/*! @page sm State Machines
@tableofcontents
@nav{bm_lock,sm_statechart}

<p>QM&trade; provides extensive support for modern <a class="extern" target="_blank" href="https://www.state-machine.com/fsm/#HSM">Hierarchical State Machines (HSMs)</a> (UML Statecharts), which are perhaps the most effective and elegant technique of structuring event-driven systems. In fact, QM&trade; has been specifically designed for ease of diagramming HSMs and for generating efficient, production-quality code from them.
</p>

The most important innovation of HSMs over classical finite state machines (FSMs) is the hierarchical state nesting. The value of state nesting lies in avoiding repetitions, which are inevitable in the traditional "flat" FSM formalism and are the main reason for the "state-transition explosion" in FSMs. The semantics of state nesting allow substates to define only the differences of behavior from the superstates, thus promoting sharing and reusing behavior.

@note
The Quantum Leaps Application Note <a class="extern" target="_blank" href="https://www.state-machine.com/doc/AN_Crash_Course_in_UML_State_Machines.pdf"><strong>A Crash Course in UML State Machines</strong></a> introduces the main state machine concepts backed up by examples.
@n
[![Application Note: A Crash Course in UML State Machines](AN_Crash_Course_in_UML_State_Machines.gif)](https://www.state-machine.com/doc/AN_Crash_Course_in_UML_State_Machines.pdf)

This section focuses primarily on working with **state machine diagrams**, while the section @ref ce_sm will cover generating code from state machines. Of course, these two aspects are related, so even while "simply drawing" state machine diagrams, you will need to take code generation into account.

@note
Section @ref bm_diagram describes generic operations applicable to any diagram type, such as @ref bm_diagram_open "opening", @ref bm_diagram_close "closing", @ref bm_diagram_scroll "scrolling", @ref bm_diagram_pan "panning", and @ref bm_diagram_zoom "zooming" a diagram. Section @subpage sm_statechart "Working with Statecharts" describes specific operations applicable to statecharts (UML state diagrams).

<div style="clear:both;"></div>


@section sm_class State Machine Base Classes
In QM&trade; a State Machine can be associated only with a @ref bm_class "class" that is a direct or indirect subclass of the @ref bm_qp_item "QP Framework" base class **QHsm**, shown at the top of the <a class="extern" target="_blank" href="http://en.wikipedia.org/wiki/Class_(computer_programming)">class diagram</a> @ref sm_super "below".

@anchor sm_super
@image html "qp_sm.gif" "State Machine Classes in QP 5.8+"

The <span style="background-color:#aaf;"> **QHsm** </span> base class provides the basic interface `init()` and `dispatch()` for initializing a state machine and for dispatching events to it, respectively. The specific implementations of the state machine interface in the `QHsm` base class and its subclasses, such as **QActive**, **QMsm**, and **QMActive**, determine the @ref ce_sm "state machine implementation strategy" that QM&trade; will apply to generate code.

@note
QM&trade; supports **classes** and **inheritance** regardless of the target programming language, which currently can be either **C** or <strong>C++</strong>. The <a class="extern" target="_blank" href="https://www.state-machine.com/doc/AN_Simple_OOP_in_C.pdf">Application Note "Simple Object-Oriented Programming in C"</a> describes how the <a class="extern" target="_blank" href="https://www.state-machine.com/qpc">QP/C</a> and <a class="extern" target="_blank" href="https://www.state-machine.com/qpn">QP-nano</a> frameworks as well as the QM&trade; code generator implement *classes* and *inheritance* in portable **ISO C**.


@subsection sm_class_qhsm The QHsm-Style State Machines
The <span style="background-color:#AAF;"> **QHsm** and **QActive** </span> classes from the @ref sm_class "class diagram above" implement the @ref ce_qhsm_strategy  that was originally designed for **manual coding** of HSMs, but now can also benefit from automatic code generation by QM&trade;

The screen shot below shows how to select the **superclass** property of your state-machine/active-object class in the @ref bm_class_prop, so that it uses the `QHsm/QActive`-Sytle state machine implementation strategy:

@image html sm_qhsm-style.png "Selecting QHsm/QActive-Style Superclass"

The QHsm-style state machine code is highly readable and human-maintainable, but it requires discovering the *transition-sequences* (sequences of exit/entry/initial actions) at run-time as opposed to code-generation time.

@attention
Apart from changing the superclass property in the class Property Sheet, you also need to call the right superclass' **constructor** in the constructor of your state machine class. For direct subclasses of <span style="background-color:#AAF;"> **QActive** </span>, you need to call `QActive_ctor()` (for the QP/C and QP-nano frameworks) and `QActive::QActive()` (for the QP/C++ framework).

@image html sm_qhsm-ctor.png "Calling the QActive_ctor() in the subclass' constructor"

@note
You should consider `QHsm/QActive`-style state machines only when you are still interested in **manual coding** or maintaining your state machines. (But then you will be working against the strictly @ref ab_special "forward-engineering nature" of QM&trade;)


@subsection sm_class_qmsm QMsm/QMActive-Style State Machines
The <span style="background-color:#FAA;"> **QMsm** and **QMActive** </span> classes from the @ref sm_class "class diagram above" re-implement the state machine interface and thus provide an alternative @ref ce_qmsm_strategy that is more efficient than the @ref sm_class_qhsm "QHsm-sylte strategy", but requires the assistance of the QM&trade; tool (as an advanced "state machine compiler") to generate the complete *transition-sequences* at *code-generation* time. The resulting code is still **highly human-readable**, but is **not** suitable for manual coding or maintaining.

@note
The QMsm/QMActive base classes are __not__ provided in the QP-nano framework, and consequently the `QMsm/QMActive` state machine implementation strategy is __not__ available in QP-nano.


The screen shot below shows how to select the **superclass** property of your state-machine/active-object class in the @ref bm_class_prop, so that it uses the QMsm/QMActive-Sytle state machine implementation strategy:

@image html sm_qmsm-style.png "Selecting QMsm/QMActive-Style Superclass"

The lab tests indicate that the `QMsm/QMActive`-style state machines can be about twice as fast as the `QHsm`-style state machines (see the @ref sm_class_qhsm "next section" below). Additionally, the `QMsm/QMActive`-style state machines require less runtime support (smaller event processor) and use about 70% less of stack space for the `dispatch()` operation than `QHsm/QActive`-style state machines.

@attention
Apart from changing the superclass property in the class Property Sheet, you also need to call the right superclass' **constructor** in the constructor of your state machine class. For direct subclasses of <span style="background-color:#FAA;"> **QMActive** </span>, you need to call `QMActive_ctor()` (for the QP/C framework) and `QMActive::QMActive()` (for the QP/C++ framework).

@image html sm_qmsm-ctor.png "Calling the QMActive_ctor() in the subclass' constructor"

@note
The `QMsm/QMActive`-style state machines are generally recommended over the older `QHsm/QActive`-style state machines described @ref sm_class_qhsm "above". You should consider `QHsm/QActive`-style state machines only when you are still interested in **manual** coding or maintaining your state machines. (But then you will be working against the strictly @ref ab_special "forward-engineering nature" of QM&trade;)

@attention
The `QMsm/QMActive`-style implementation strategy requires a @ref ab_license "commercial license certificate" to generate code.


@section sm_toolbox State Machine Toolbox
When a State Machine diagram is active, the @ref sm_toolbox displays tools a specific collection of tools for **adding** new shapes to the active State Machine.

@note
The State Diagram Toolbox is **enabled** only when a state diagram is the active MDI window and the model is @ref bm_lock "unlocked" (<span class="img unlock"></span>). If the Toolbox is <span class="highlight">invisible</span>, you need to show it with in the <span class="menu"> View-&gt;Draw Toolbar</span> menu.

<div style="clear:both;"></div>

The usage of the tools in the State Diagram Toolbox is explained in the sections pertaining to the corresponding state machine elements:

- <span class="img state"></span> @subpage sm_state   "Add State"
- <span class="img tran"></span> @subpage sm_tran     "Add Transition"
- <span class="img choice"></span> @subpage sm_choice "Add Choice Segment"
- <span class="img initial"></span> @subpage sm_init  "Add Initial Transition"
- <span class="img history"></span> @subpage sm_hist  "Add Transition to History"
- <span class="img submachine"></span> @subpage sm_subm "Add Submachine Diagram"
- <span class="img ep_seg"></span> @subpage sm_epseg   "Add Entry-Point Segment"
- <span class="img xp"></span> @subpage sm_xp          "Add eXit-Point"
- <span class="img sm_state"></span> @subpage sm_smstate "Add Submachine State"
- <span class="img xp_seg"></span> @subpage sm_xpseg   "Add eXit-Point Segment"


@nav{bm_lock,sm_statechart}
*/
/*==========================================================================*/
/*! @page sm_statechart Working with Statecharts
@tableofcontents
@nav{sm,sm_state}

@section sm_add Adding a Statechart
In the @ref ui_explorer **right-click** on the @ref bm_class "Class" to which you want to add the state machine and select <span class="img statechart">Add State Machine</span> from
 the popup menu.

@image html "blinky_sm_add.gif" "Adding a State Machine to a Class"

@note
The <span class="menu">Add State Machine</span> menu option is only available if a given @ref bm_class "class" directly or indirectly inherits the @ref sm_class "QP class QHsm". Otherwise the option is "grayed-out".



@section sm_resize Resizing a State Machine Diagram
As shown in the screen shot below, you can easily resize the @ref bm_diagram_canvas "Drawing Canvas" of a State Diagram by dragging its right or bottom edges, or by dragging the resize handle in the bottom-right corner of the canvas. In each case the mouse cursor indicates the possible direction of resizing.

@image html bm_diagram-canvas.gif "Resizing the Drawing Canvas"



@section sm_statechart_prop Statechart Property Sheet
<span class="img statechart">Statechart</span> item can be configured by the Statechart-Specific @ref ui_prop "Property Sheet".

@image html "sm_statechart_prop.png" "Statechart Property Sheet"

The statechart-item property sheet contains the following properties:


@subsection sm_statechart-use-me Use "me->"
Checkbox that controls the state machine implementation style. When checked, the old **use me-> pointer** style is applied. If unchecked (recommended), the new **no me-> pointer** style is used. Please refer to the [QP/C++ documentation of this feature](https://www.state-machine.com/qpcpp/sm.html).

@note
The **Use me->** checkbox is only relevant for models based on QP/C++ (qpcpp). For models based on QP/C or QP-nano, this checkbox is permanently checked and is "grayed-out" meaning that it cannot be unchecked.


@subsection sm_statechart-QS QS_FUN_DICT
Checkbox that turns on/off the automatic generation of the [QS_FUN_DICTIONARY()](https://www.state-machine.com/qtools/qs.html#qs_dict) macros for all states of a given statechart. The dictionary macros are generated in the top-most initial transition of the statechart. Below is an example of generated code with the `QS_FUN_DICTIONARY()` macros:

@code{c}
/*${SMs::Calc::SM} .........................................................*/
static QState Blinky_initial(Blinky * const me, void const * const par) {
    /*.${AOs::Blinky::SM::initial} */
    (void)par; /* unused parameter */
    . . .
    QS_FUN_DICTIONARY(&Blinky_off);
    QS_FUN_DICTIONARY(&Blinky_on);

    return Q_TRAN(&Blinky_off);
}
@endcode

@subsection sm_statechart-doc Documentation
The **documentation** entry in the Statechart Property Sheet allows you to provide documentation to the statechart. The QM code generator parses the documentation entry and can @ref ce_comment-doc "generate comments" for the **top-most initial transition** of this statechart.

@nav{sm,sm_state}
*/
/*==========================================================================*/
/*! @page sm_state Working with States
@tableofcontents
@nav{sm_statechart,sm_tran}

<p>The concept of <strong>State</strong> is a very effective mechanism of decomposing event-driven behavior. *States* divide the overall behavior of a class into separate parts, each part (state) handling events in a specific way. Any change in handling of any event requires a change of state, that is, a state @ref sm_tran "transition". States are represented in UML as rounded-corner rectangles with the state name at the top.
</p>
<div style="clear:both;"></div>


@section sm_state_add Adding a State
@note
In order to add states, you first need to @ref sm_add "create" and @ref bm_diagram_open "show" a state diagram. Also, to add, move, resize, or edit states, the State Machine diagram must be @ref bm_lock "unlocked" (<span class="img unlock"></span>).

Make sure that the State Machine subwindow is active. In the @ref sm_toolbox click on the <span class="img state">State</span> tool and *release* the mouse button (don't drag the tool off the toolbar). At this point, when you hover the mouse over the active state diagram, the mouse pointer changes shape to the <span class="img cur_state1">state</span> tool. To add a state, move the mouse to the desired location of the **top-left corner** of the state shape and press the left mouse button. At this point you create a state shape of minimal size at the mouse position. You can release the mouse button immediately or you can **drag** the mouse to the desired location of the **bottom-right** corner of the state shape. In any case, you can @ref sm_state_resize "resize" the state shape at any later time.

@image html sm_state-add.gif "Adding a State"


@section sm_state_nest Nesting of States
One of the most important features of <a class="extern" target="_blank" href="https://www.state-machine.com/fsm/#HSM">Hierarchical State Machines (HSMs)</a> (UML Statecharts) is that states can **nest** within other states, thus forming state hierarchies. In fact, QM&trade; has been specifically designed for ease of working with such hierarchically nested states.

QM&trade; determines state nesting by the **geometric** arrangement of states in the diagram, whereas state nesting is determined only by the position of the <span>top-left corner</span> of the state rectangle. This state hierarchy is immediately reflected in the @ref bm_model "hierarchical model view" in the @ref ui_explorer dock window.

@note
The rule of using just the top-left corner to determine state nesting (as opposed to complete enclosure of one state by another) turns out to be more useful in practice, because it leads to fewer inadvertent changes in state nesting when states are rearranged during diagram editing.

@image html "sm_state_nest.png" "Example of Nested States"

For example, the screen shot above shows `state2` nested in `state1`, as identified clearly in the @ref ui_explorer on the left of the picture. Please note that only the upper-left corner of `state2` is inside `state1`, instead of being entirely enclosed by `state1`. On the other hand, state `state3` nests entirely inside `state2`, and indirectly in `state1` as well.

@note
The state nesting is also reflected in the @ref sm_state-super property in the State Property Sheet.


@section sm_state_move Moving a State
To move a state, hover the mouse over the state until you get the move cursor. Click the mouse and drag the state shape to the desired location.

@image html "sm_state-move.gif" "Moving a State"


@section sm_state_resize Resizing a State
You can resize all four edges of a state shape. The top and bottom edges can be resized up and down, while left and right edges can be resized left and right. Additionally, the right-bottom corner can be resized diagonally (i.e., both horizontally and vertically).

To resize the desired edge of a state, hover the mouse over the state edge until you get the resize cursor. Click the mouse and drag the state edge to the desired location.

@image html "sm_state-resize.gif" "Resizing a State"

@note
The state shape cannot be made smaller than the @ref sm_state-entry "entry box" and @ref sm_state-exit "exit box" in the state.


@section sm_state_delete Deleting a State
To delete a state, you need to select it as the @ref ui_curr_item "Current Item", either by clicking on it in the state diagram or in the @ref ui_explorer "Model Explorer". After this, you can delete the state in several ways: (1) click the <span class="img delete">button</span> in the @ref ui_explorer_delete  "Explorer Toolbar"; (2) press the <span class="button">Del</span> keyboard shortcut; or (3) right-click on the state diagram and choose the <span class="menu">Delete item</span> option from the pop-up menu (see the screen animation below).

@image html "sm_state-del.gif" "Deleting a State"

@note
Deleting a state is **not recursive**, meaning that any substates nested within the deleted state are **not** deleted.


@section sm_state_prop State Property Sheet
<span class="img state">State</span> item can be configured by the State-Specific @ref ui_prop "Property Sheet".

@image html "sm_state_prop.png" "State Property Sheet"

The state-item property sheet contains the following properties:

- @ref sm_state-name
- @ref sm_state-super (not editable; see @ref sm_state_nest)
- @ref sm_state-doc
- @ref sm_state-entry
- @ref sm_state-exit


@subsection sm_state-name State Name
The state **name** should be a valid function name in C or C++. Typically, you should strive for a short and punchy name that captures the nature of the state. For example, a state in which a system remains on could be named `on`. To keep with the naming conventions used in @ref gs_exa "QM examples", it is recommended to name use lower-case names of states.


@subsection sm_state-super Superstate
The **superstate** property is not directly editable in the State Property Sheet, because the superstate of the given state is determined @ref sm_state_nest "geometrically".

@note
If a state is placed directly on the drawing canvas and does not nest in any other state, the *superstate* property shows "top", which is the implicit **top-most state** that encloses all states in the diagram and is the ultimate root of the state hierarchy.


@subsection sm_state-doc State Documentation
The **documentation** entry in the State Property Sheet allows you to provide documentation to the state. The QM code generator parses the documentation entry and can @ref ce_comment-doc "generate comments" from it in the auto-generated code.


@subsection sm_state-entry State Entry Action
A state can have optional **entry action**. You provide this action in the @ref sm_state_prop "State Property Sheet" (see also the screen shot below). If defined, the entry action shows up in the upper-left corner of the state shape.

An entry action is considered defined if the corresponding **pseudocode** or **code** entries in the @ref sm_state_prop "State Property Sheet" are not empty. Once an entry action is defined the state shape shows the **entry box** in the upper-left corner just
 below the name compartment.

@note
The **pseudocode** property is designed to avoid clutter in the diagram by minimizing the amount of text to display inside the state shape in the diagram. **Pseudocode** is intended only for displaying in the diagram and has <span>no implications for code generation</span>.

The actual algorithm QM uses to display action text in the entry box is as follows: If both the *pseudocode* and *code* entries in the State Property Sheet are empty, the corresponding entry action is considered undefined and is **not displayed** at all in the state shape. If the pseduocode entry is not empty, regardless of the contents of the code entry, the *pseudocode* is displayed in the **same line** as the `e/` (<strong>e</strong>ntry) text. Finally, if the *pseudocode* is empty, but the *code* entry is not empty, the *code* is displayed in the entry text box of the state shape, however, the actual *code* is displayed in a line **below** the `e/` text. Of course, to see the text, you need to expand the entry text box in the state shape.

@image html "sm_state-entry.gif" "Resizing the State Entry Box"

Once the state shape is *selected* as the @ref ui_curr_item "Current Item", you can **resize the entry box** by dragging the lower-right handle of the box (see the screen animation above).


@subsection sm_state-exit State Exit Action
A state can have optional **exit action**. You provide this action in the @ref sm_state_prop "State Property Sheet" (see also the screen shot below). If defined, the exit action shows up just below the entry action (if defined) in the upper-left corner of the state shape.

An exit action is considered defined if the corresponding **pseudocode** or **code** entries in the @ref sm_state_prop "State Property Sheet" are not empty. Once an exit action is defined the state shape shows the **exit box** in the upper-left corner just below the entry action.

@attention
The **pseudocode** property is designed to avoid clutter in the diagram by minimizing the amount of text to display inside the state shape. **Pseudocode** is intended only for displaying in the diagram and has **no implications** for code generation. Only the **Code** entry of the *exit* property matters for code generation.

@note
The actual algorithm QM uses to display action text in the exit box is as follows: If both the *pseudocode* and *code* entries in the State Property Sheet are empty, the corresponding exit action is considered undefined and is **not displayed** at all in the state shape. If the *pseduocode* entry is not empty, regardless of the contents of the *code* entry, the pseudocode is displayed in the **same line** as the `x/` (e<strong>x</strong>it) text. Finally, if the *pseudocode* is empty, but the *code* entry is not empty, the code is displayed in the exit text box of the state shape, however, the actual code is displayed in a line **below** the `x/` text. Of course, to see the text, you need to expand the exit text box in the state shape.

@image html "sm_state-exit.gif" "Resizing the State Exit Box"

Once the state shape is *selected* as the @ref ui_curr_item "Current Item", you can **resize the exit box** by dragging the lower-right handle of the box (see the screen animation above).

@nav{sm_statechart,sm_tran}
*/
/*==========================================================================*/
/*! @page sm_tran Working with Transitions
@tableofcontents
@nav{sm_state,sm_choice}

@section sm_tran_reg Regular Transitions
<p>Any change in handling of events requires a change of state, that is, a **state transition**. Such **state-to-state transitions** are represented as lines that originate on an edge of the *source state* and terminate with an arrow (<span class="img tran_state"></span>) on an edge of the *target state*.
</p>

![State-to-State Transition](sm_tran_source.png)

@note
All connectors in QM&trade; diagrams, such as transitions, consists of **rectilinear segments** only (strictly horizontal or strictly vertical lines). The usability studies, such as public transport diagrams (e.g., Back's maps) show that restricting a diagram to straight segments running only horizontally, vertically, (and sometimes diagonally) greatly improve the readability of the diagrams.


@section sm_tran_intern Internal Transitions
However, often you only need to simply *react* to an event (by executing some actions) *without* changing states. In UML such a situation should be modeled with **internal transitions**. Internal transitions are represented in UML as text inside the state compartment (see part (A) of the figure below).

![Internal Transitions in UML (A) and in QM&trade;(B)](sm_intern.png)

In QM&trade; internal transitions are represented as a transition without a target (see part (B) of the figure above). Visually, the end of such transition shows as a small rectangle (<span class="img tran_internal"></span>) instead of an arrow (<span class="img tran_state"></span>).

@note
The QM&trade; representation of internal transitions differs from the <a class="extern" target="_blank" href="http://en.wikipedia.org/wiki/UML_state_machine#Internal_transitions">standard UML notation</a> and therefore is a <span class="highlight">"non-normative UML"</span>.

![Internal Transition and Self-Transition in QM](sm_tran_self.png)

@note
Internal transitions are **different** from *self-transitions* (loops starting and terminating on the same state), because self-transitions cause exit of the state (execution of exit actions) and re-entry to the state (execution of entry actions followed by optional initial transitions), whereas internal transitions never cause state exit or entry.


@section sm_tran_add Adding a Transition

@note
In order to add a transition, you first need to @ref bm_diagram_open "open" a state diagram, which needs to have at least one @ref sm_state "state". Also, the State Machine diagram must be @ref bm_lock "unlocked" (<span class="img unlock"></span>).

Make sure that the State Machine subwindow is active. In the @ref sm_toolbox click on the <span class="img tran">Transition</span> tool and *release* the mouse button (don't drag the tool off the toolbar). At this point, when you hover the mouse over the active state diagram, the mouse pointer changes to the transition tool with the  "forbidden" icon (<span class="img forbidden"></span>), because a transition can only be added to an **edge** of a state. When you hover the mouse over a state edge, the mouse pointer changes to the transition tool with the anchor (<span class="img anchor"></span>). To add the transition at this **source** state, press the mouse button and drag the transition end out. As you drag the transition, the mouse pointer changes to a hand and the transition end takes the shape of a square (<span class="img tran_internal"></span>).

@attention
As shown in the animations below, a transition (state-to-state or internal) in QM&trade; is always added to the **Source State**, meaning that it shows up in the @ref ui_explorer "Model Explorer" as a child of the **Source State** item.


@subsection sm_tran_add-internal Adding Internal Transition
If you drop the transition end when it still shows as a square (<span class="img tran_internal"></span>), the transition will become an **internal transition** (a.k.a. state reaction). The following animation shows how to add an internal transition:

@anchor sm_tran_anim
@image html sm_tran_internal-add.gif "Adding an Internal Transition"

@note
As described in section @ref sm_tran_type, you can very easily change an *internal transition* into a regular *state-to-state transition* or vice versa.


@subsection sm_tran_add-state Adding State-to-State Transition
To add a regular **state-to-state transition**, you need to drag the transition end to an edge of the **target** state. As you drag the transition end over a state edge (which could be the source state), the mouse pointer changes to a hand shape with an anchor (<span class="img anchor"></span>) and the transition end takes the shape of an arrow. If this is the desired **target** state, drop the transition end at this point. The following animation shows how to add a state-to-state transition:

@image html sm_tran_state-add.gif "Adding a State-to-State Transition"


@section sm_tran_prop Transition Property Sheet
<span class="img tran">Transition</span> item can be configured by the Transition-Specific @ref ui_prop "Property Sheet".

@image html "sm_tran_prop.png" "Transition Property Sheet"

The Transition property sheet contains the following properties:
- @ref sm_tran-trig
- @ref sm_tran-target (not editable--determined geometrically)
- @ref sm_tran-act


@subsection sm_tran-trig Transition Trigger
Every transition in QM&trade; must have an explicit **trigger**, which is the name of the **signal** of the event that triggers the transition (NOTE: QM&trade; does **not** support trigger-less <i>"anonymous transitions"</i>). The *trigger* shows up in the @ref sm_tran_text "Text Box" associated with the Transition.

The *trigger* property must be a legal symbolic constant representing the **signal** of the triggering event. Typically, the event signals are enumerated constants, and by the C convention are all in uppercase, for example: `TIMEOUT`, `OPEN`, `CLOSE`, etc.

@attention
By convention, QM&trade; @ref ce_sm "code generator" appends the suffix <strong>`_SIG`</strong> to the *trigger* property you type into the Property Editor. For example, triggers `TIMEOUT`, `OPEN`, and `CLOSE` will appear in the generated code as `TIMEOUT`<strong>`_SIG`</strong>, `OPEN`<strong>`_SIG`</strong>, and `CLOSE`<strong>`_SIG`</strong>, respectively.

@subsubsection sm_tran_trig-list Trigger List
The *trigger* property might also be a **list** of event *signals* that trigger the transition, which is a shorthand notation for a group of transitions that all
 target the same state and execute the same actions. For example, you might provide a single *trigger* property as: `"TIMEOUT, OPEN, CLOSE"`, which means that **all** of the listed signals will trigger the transition.

@image html sm_tran_list.png "Transitions with a Trigger List"

@note
The QM&trade; @ref ce_sm "code generator" will convert the trigger list into a list of `case` statements that "fall through" into each other.

@subsubsection sm_tran_CATCH_ALL CATCH_ALL Trigger
As an extension to the UML, QM&trade; supports also a special type of **CATCH_ALL** transition trigger. This trigger means that the transition will be trigger by any event that is **not** handled explicitly by any other transition in the state.

@image html sm_tran_CATCH_ALL.png "CATCH_ALL Transition"

@note
Obviously, it does not make sense to have more than one `CATCH_ALL` transition per state. The QM&trade; @ref ce_sm "code generator" will report an error if encounters multiple `CATCH_ALL` triggers in a given state.


@subsection sm_tran-target Transition Target
The **target** property is not editable directly, but rather it is determined geometrically by the end-point of the transition. For *state-to-state transitions*, the *target* property lists the target state at which the end-point (<span class="img tran_state"></span>) terminates. For *internal transitions* with the square end-point (<span class="img tran_internal"></span>), the *target* property shows `internal`.


@subsection sm_tran-act Transition Action
A Transition can have optional **action** property, which consists of two entries: *pseudocode* and *code* (see @ref sm_tran_prop "Transition Property Sheet"). Only the **code** part of the *action* property is relevant for the @ref ce "code generation". The **pseudocode** field is designed only to be displayed in the diagram to avoid clutter by minimizing the amount of text to display next to the transition shape.

@attention
The <strong>Pseudocode</strong> entry of the *action* property is intended only for displaying in the diagram and has <span>no implications for code generation</span>. Only the <strong>Code</strong> entry of the *action* property matters for code generation.

@anchor sm_tran_e-ptr
<strong>Pointer to the Triggering Event (<span class="highlight">e</span>):</strong> The transition action **code** often needs to access the triggering event, which is provided as the <span>e</span> pointer of the type `(QEvt const * const)`. This means that you have **read-only** access to the event, and you cannot change the `e` pointer.

@anchor sm_tran_e-par
<strong>Accessing Event Parameters:</strong> To access **event parameters** of the triggering event, you typically need to **downcast** the event pointer <strong>e</strong>. This downcast is always based on the transition **trigger** (signal of the triggering event, see @ref sm_tran-trig), which means that you must always know the **event type** (event class) associated with the trigger.


@section sm_tran_text Transition Text Box
Once the transition item is *selected* as the @ref ui_curr_item "Current Item", you can see boundary of the **Text Box** associated with the transition. The Text Box allows you to **move** and **resize** the transition text by dragging it around or dragging the Text Box Handle (see the screen animation below).

@image html "sm_tran_text.png" "Transition Text Box"


The Text Box allows you to **move** and **resize** the transition text by dragging it around or dragging the Text Box Handle (see the screen animation below).

@image html "sm_tran-text.gif" "Moving and Resizing the Transition Text Box"

@anchor sm_tran-text
@note
The actual algorithm QM uses to display the action text in the text box is as follows: If both the **pseudocode** and **code** entries in the @ref sm_tran_prop "Transition Property Sheet" are empty, the corresponding action is considered undefined and the Text Box associated with the transition shows only the `&lt;TRIGGER&gt;/` string. If the *pseduocode* entry is not empty, regardless of the contents of the *code* entry, the *pseudocode* is displayed in the *same line* as the `&lt;TRIGGER&gt;/` string. Finally, if the *pseudocode* is empty, but the *code* entry is not empty, the *code* is displayed in the Text Box of the transition, however, the actual code is displayed in a line **below** the `&lt;TRIGGER&gt;/` string. Of course, to see the text, you need to sufficiently expand the Text Box of the transition, as shown in the animation above.


@section sm_tran_type Changing Transition Type
At any point, you can very easily change an *internal transition* into a regular *state-to-state transition* by simply dragging the square end (<span class="img tran_internal"></span>) and "anchoring" it at an edge of a state, at which point it becomes an arrow (<span class="img tran_state"></span>). This is one of the many benefits of the "non-normative" transition notation used in QM&trade;


@section sm_tran_routing Routing Transitions
QM&trade; allows you to route your transitions (all connectors, in fact) any way you like. You can create any number of rectilinear segments and you can move them around. The following animation shows how to the segments on both ends can be used to create new edges, how to move them, and how to remove segments.

![Routing a transition in QM&trade;](sm_route-anim.gif)

One of the primary design objectives in QM&trade; was to respect your design decisions as much as possible and avoid the need to "fight the tool". In this respect, noting is more frustrating than a tool that suddenly changes the arrangement of your transitions, after you spent hours routing them exactly the way you like. QM&trade; will never to that. Instead, QM&trade; will change at most 2 first or last transition segments attached, depending if you are moving the beginning or end of the transition.

![QM Preserves the layout of a transition](sm_tran-anim.gif)


@section sm_tran_guards What About Guards?
A very important feature of state transitions in UML is the support for **guard conditions** (often simply called "guards"). A guard condition is a Boolean expression that can be associated with a transition, which means that the transition should be taken only when the guard dynamically evaluates to TRUE. If the guard evaluates to FALSE, the transition is _not_ taken and any action(s) associated with the transition are _not_ executed.

In QM&trade; state transitions do **not** accept guard conditions. Instead, you can attach any number of @ref sm_choice "choice segments" to the end of a transition, which creates alternative transition path(s) evaluated dynamically at run-time. You can even attach choice-segments to choice-segments to build even more complex transition paths. All this provides actually a _more powerful_ and intuitive mechanism than simple "guards" on transitions.

@image html "sm_guard.png" "UML Notation for a Transition with a Guard (A) and a Transition with a Choice Pseudostate (B)"

@note
The UML supports the concept of a "choice-pseudostate", which is an alternative to guards on transitions. QM&trade; supports the UML "choice-pseudostates" in form of @ref sm_choice "choice segments". The concept and notation for "choice pseudostate" (panel (B) in the diagram above) **is** compliant with UML.

@nav{sm_state,sm_choice}
*/
/*==========================================================================*/
/*! @page sm_choice Working with Choice Segments
@tableofcontents
@nav{sm_tran,sm_init}

<p>Often in state machines, you need to take a state transition only when a specific condition (called **guard condition**) evaluates to TRUE at run-time. Also, quite often, you need to transition to different states, depending on the outcome of some guard conditions evaluated at run-time.
</p>
The UML provides a special construct, called "choice pseudostate", which you can use in such situations.
A "choice pseudostate" allows you to split a transition into multiple outgoing paths, each one with its own _guard condition_.

![UML Choice pseudostates with one outgoing path (A) and two outgoing paths (B)](sm_choice.png)

@note
It is useful to think about the choice pseudostate, such as the one shown in panel (B) of the diagram above, as the compound `if (guard1()) {...} else if (guard2()) {...}` statement (this is in fact how the @ref ce "QM&trade; code generator" implements choice segments).

@attention
Because guards lead to `IF`s and `ELSE`s in the code, overusing them leads to "spaghetti" code and defeats the purpose of using state machines in the first place. For that reason guards should be used **judiciously**.

In most UML tools, the process of drawing choice segments consists of first adding a "choice pseudostate" (diamond) and then attaching an outgoing transition segment with a guard. In QM&trade; this process is simplified, because the @ref sm_toolbox "State Machine Toolbox" contains ready-to-use <span class="img choice">Choice Segment</span> tool, which combines a "choice pseudostate" with a transition segment attached permanently to it.

@note
<span class="img choice">Choice Segment</span> is the only way in QM&trade; to attach a **guard condition** to a transition, as illustrated in panel (A) of the diagram above. But the QM&trade; Choice Segment is more powerful than simple guards on transitions, as explained in the following sections.


@section sm_choice_add Adding Choice Segment
@note
In order to add a choice segment, you first need to @ref sm_add "create" and @ref bm_diagram_open "show" a state diagram. Additionally, the state machine must have at least one @ref sm_tran_intern "internal transition" (terminated with <span class="img tran_internal"></span>) or a choice segment (<span class="img tran_choice"></span>). Finally, to add, move, resize, or edit choice segments, the State Machine diagram must be @ref bm_lock
 "unlocked" (<span class="img unlock"></span>).

Make sure that the State Machine subwindow is active. In the @ref sm_toolbox click on the <span class="img choice">Choice Segment</span> tool and *release* the mouse button (don't drag the tool off the toolbar). At this point, when you hover the mouse over the active state diagram, the mouse pointer changes to the choice-segment tool with the "forbidden" icon (<span class="img forbidden"></span>), because a choice-segment can only be added to an <span class="highlight">unattached square-end of a transition (<span class="img tran_internal"></span>) or to an existing choice segment (<span class="img tran_choice"></span>)</span>. When you hover the mouse over an allowed attachment point for a choice-segment, the mouse pointer changes to the choice segment tool with the anchor (<span class="img anchor"></span>). To add the choice segment to this attachment point, press the mouse button and drag the choice segment end out to the desired _edge_ of the target state. The transition path thus established will correspond to a regular **state-to-state transition** with a guard.

![Adding an state-to-state transition Choice Segment](sm_choice_tran-ani.gif)

You can also add a choice segment that will become an **internal transition** with a guard. To do this, you simply drag the end of the choice segment and drop it not on any state edge. At this point, the choice-segment will become an **internal** transition. Internal transition is executed entirely within the source state and never leads to a change of state.

![Adding an internal transition Choice Segment](sm_choice_int-ani.gif)

@note
The standard "normative" UML notation does not allow you to add internal transition segments to choice pseudostates. In contrast, the @ref sm_tran_intern "non-normative representation of internal transitions" in QM&trade; allows you to easily add **internal transition segments** to choice pseudostates and to quickly and intuitively change the transition type by attaching/detaching the transition end to/from a state.

@anchor sm_choice_add-nest
Finally, you can also add a choice segment to an unattached end of another choice segment, as illustrated in the animation below:

![Adding an internal transition Choice Segment](sm_choice_nest-ani.gif)

@note
This option of adding Choice Segments to already existing Choice Segments means that you can build complex **nested** guards. However, as with all guard conditions, you should use this feature **judiciously** to avoid "spaghetti" code.


@section sm_choice_prop Choice Segment Property Sheet
<span class="img choice">Choice Segment</span> item can be configured by the Choice-Specific @ref ui_prop "Property Sheet".

@image html "sm_choice_prop.png" "Choice-Segment Property Sheet"

The Choice Segment property sheet contains the following properties:
- @ref sm_choice-guard
- @ref sm_choice-target (not editable--determined geometrically)
- @ref sm_choice-act


@subsection sm_choice-guard Choice Guard
Every choice segment in QM&trade; must have an explicit **guard** property, which consists of two entries: *pseudocode* and *code*. Only the **code** entry of the *guard* property is relevant for the @ref ce "code generation". The **pseudocode** entry is designed only to be displayed in the diagram to avoid clutter by minimizing the amount of text to display next to the transition shape.

@attention
The <strong>Pseudocode</strong> entry of the *guard* property is intended only for displaying in the the @ref sm_choice_text "Text Box" associated with the choice segment, but it has <span>no implications for code generation</span>.

@note
The _guard_ property is displayed in the Text Box of the choice segment according to the same rules as the @ref sm_tran_text "Transition Text Box". Additionally, to reduce the clutter in the diagram, the _guard_ is shown in an <span class="highlight">abbreviated form</span>, where all spaces in the _guard_ are removed and the resulting guard text is truncated at 32 characters. (When the guard is <span class="highlight">truncated</span>, the last character is '<span class="highlight">~</span>').

For successful code generation, the Code entry of the _guard_ property must be a legal C or C++ Boolean expression. The expression can use the state machine attributes (via the **me** pointer), and the event parameters of the triggering event (see section below).

@anchor sm_choice_e-ptr
<strong>Accessing the Triggering Event:</strong> The guard expression can access the original triggering event (of the transition to which the choice is attached directly or indirectly), which is provided as the **e** pointer of the type `(QEvt const * const)`. This means that you have _read-only_ access to the event, and you cannot change the `e` pointer. To access *event parameters* of the original triggering event, you typically need to _downcast_ the event pointer <strong>e</strong>. This downcast is always based on the transition _trigger_ (signal of the triggering event, see @ref sm_tran-trig), which means that you must always know the _event type_ (event class) associated with the trigger.


@subsection sm_choice-target Choice Target
The **target** property is not editable directly, but rather it is determined geometrically by the end-point of the choice segment. For *state-to-state transitions*, the *target* property lists the target state at which the end-point (<span class="img tran_state"></span>) terminates. For *internal transitions* with the square end-point (<span class="img tran_internal"></span>), the *target* property shows `internal`.


@subsection sm_choice-act Choice Action
A Choice Segment can have optional **action** property, which is executed only when the _guard_ evaluates to TRUE at runtime (see also @ref sm_choice_act).

The action property consists of two entries: *pseudocode* and *code* (see @ref sm_choice_prop "Choice Property Sheet"). Only the **code** part of the *action* property is relevant for the @ref ce "code generation". The **pseudocode** field is designed only to be displayed in the diagram to avoid clutter by minimizing the amount of text to display next to the transition shape.

@note
The <strong>Pseudocode</strong> entry of the _action_ property is intended only for displaying in the diagram and has <span>no implications for code generation</span>.

@anchor choice_e-par
<strong>Pointer to the Triggering Event:</strong> The choice action **code** often needs to access the triggering event, which is provided as the <span>e</span> pointer of the type `(QEvt const * const)`. This means that you have **read-only** access to the event, and you cannot change the `e` pointer. To access _event parameters_ of the triggering event, you typically need to _downcast_ the event pointer **e**. This downcast is always based on the transition _trigger_ (signal of the triggering event, see @ref sm_tran-trig), which means that you must always know the _event type_ (event class) associated with the trigger.


@section sm_choice_text Choice Text Box
Once the Choice Segment item is *selected* as the @ref ui_curr_item "Current Item", you can see boundary of the **Text Box** associated with the choice segment. The Text Box allows you to **move** and **resize** the choice text by dragging it around or dragging the Text Box Handle according to the same algorithm as the @ref sm_tran_text "Transition Text Box".


@section sm_choice_else The else Guard
The guard property can be defined as the special **else** keyword. Such _else_ guard complements any other guard conditions attached to the same choice pseudostate. The _else_ guard can be specified either in the code entry or pseudocode entry of the _guard_ property. Obviously, the "else" guard makes sense only for a choice pseudostate with multiple outgoing <span class="img choice">choice segments</span>.

![Examples of the else guard](sm_choice_else.png)

@note
During the @ref ce "code generation", the _else_ guard will always be generated last within the group of all guards associated with the same choice pseudostate, regardless of its @ref sm_choice_order "order in the Model Explorer".


@section sm_choice_none Choice Segments Without else
According to the UML specification, an event that cannot be processed due to all guards evaluating to FALSE must be treated as unprocessed meaning that it must be propagated to the superstate(s). This requirement has implications for choice pseudostates without an explicit _else_ segment. Specifically, to comply with the UML semantics, the @ref ce "QM&trade; code generator" will generate in such cases an implicit `else` branch that will cause propagation of the event to the superstate(s).

![Choice Pseudostates With and Without Explicit else Segment](sm_choice_empty.png)

@note
There is a difference between a choice pseudostate with an empty _else_ segment and an otherwise identical choice pseudostate without the _else_ segment. The explicit empty _else_ will cause the event to be consumed (without doing anything), while the absence of the _else_ segment will cause the event to propagate to the superstate(s).


@section sm_choice_order Order of Guard Evaluation
The UML specification requires that the guard conditions attached to the same choice pseudostate be mutually _complementary_, so that the order of evaluation of the guards does not matter. While keeping the guards complementary is still recommended in QM&trade;, the tool evaluates guards always in the **predetermined order**, which you can rely on.

![Multiple Choice Segments With Overlapping Guards](sm_choice_order.png)

The order of guard evaluation is determined by the order of the <span class="img choice">Choice Segment</span> items in the @ref ui_explorer "Model Explorer". This order can be changed by means of the <span class="img move_up">Up</span> and <span class="img move_down">Down</span>
 buttons on the Explorer Toolbar. Alternatively, the @ref ui_curr_item can be moved up or down within the Model Explorer by means of the keyboard shortcuts: **Ctrl**-<span class="img key_up">(key-up)</span> and **Ctrl**-<span class="img key_down">(key-down)</span>.

![Ordered Choice Segments in Model Explorer, Diagram, and Generated Code](sm_choice_graph.png)

@note
In case of overlapping guards when the order of guard evaluation matters, it is highly recommended to arrange the Choice Segments graphically in the diagram in same order as in the Model Explorer, as illustrated in the screen shot above. The generated code will then follow the same order, as shown on the right of the diagram above.


@section sm_choice_act Order of Action Evaluation
Any choice segments attached to a transition add the choice-segment actions to the action performed by the transition. The order of evaluation of all these actions is intuitive and starts always with the transition action executed unconditionally, followed by the conditional evaluation of choice-segment actions.

![Transition Actions and Choice Actions](sm_choice_actions.png)

For example, the order of action evaluation in the diagram above is summarized by the following pseudocode:

@code{.c}
. . .
case TRIG: {
    /* transition action... */
    action0(); /* executed unconditionally */

    /* choice segments... */
    if (g1()) {
        action1();
        . . .
    }
    else if (g2()) {
        action2();
        . . .
    }
    else {
        . . .
    }
}
. . .
@endcode


@section sm_choice_nest Nested Choice Segments
As described @ref sm_choice_add-nest "above", Choice Segments can **nest**. This allows you to build complex conditional transition paths, but as always with guards, the feature should _not_ be overused.

For example, one common mistake is to use deeply nested choice segments to choose among a number of possible transition paths (see panel (A) in the diagram below):

![Deeply Nested Choice Segments (A) vs. Muliple Choice Segments (B)](sm_choice_nest.png)

A better and much simpler alternative is to use multiple choice segments attached to the **same** choice pseudostate, as shown in panel (B) in the diagram above.

@note
Remember that you can attach many choice segments to a given transition. A diagram with smaller number of choice pseudostates (diamonds <span class="img tran_choice"></span>) is a better, easier to understand diagram.

@attention
The @ref ce "QM&trade; code generator" limits the number of nesting levels in the code to 16 (including the nesting inside state-handler functions). The use of deeply-nested Choice Segments can easily exceed this limit.


@section sm_choice_routing Routing Choice Segments
A transition with multiple choice segments, some of them potentially nested, groups many elements in a small diagram space. To graphically re-arrange such a complex "ball of connectors", you need to be aware of the basic rules that apply in this situation.

The first rule is that before you can change the shape of any element, you first need to **select** it.

For example, if you want to move the choice-pseuodstate (the diamond <span class="img tran_choice"></span>), you need to click on the original incoming transition to the choice-pseudostate. Pleease note that you quite specifically should _not_ click on the diamond shape itself, because it is actually an overlapped collection of the incoming transion-end plus all the outgoing choce segments, so it is ambiguous which shape you actually mean. Instead, you shouild click on one of the transition segments or the begin-end of the transiton. (**NOTE:** You can also unambiguously select any model item in the @ref ui_explorer "Model Explorer" view). The following animation illustrates the process:

![Moving the choice-pseudostates (the diamonds)](sm_choice_move-ani.gif)

On the other hand, if you select an outgoing choice-segment, you cannot move the choice-pseudostate. Instead, you can now move just the selected choice-segment to re-attach it somewhere else.

![Changing attachment of a choice-segment](sm_choice_att-ani.gif)

@nav{sm_tran,sm_init}
*/
/*==========================================================================*/
/*! @page sm_init Working with Initial Transitions
@tableofcontents
@nav{sm_choice,sm_hist}

<p>Every state machine needs the **top-most initial transition**, which originates in an initial pseudostate (black dot) placed directly on the drawing canvas and points to the first active state after the state machine gets initialized.
</p>

Additionally, a *composite state* with nested *substates* might also have its own **nested initial transition**, which also originates in an initial pseudostate but placed _inside_ a superstate and points to the default substate that becomes active after the superstate is entered by a transition.

<div style="clear:both;"></div>

@image html "sm_init_types.png" "Top-Most and Nested Initial Transitions"

In most UML tools, the process of drawing such initial transitions consists of first adding an initial pseudostate (black dot) and then attaching a transition between it and some state. In QM&trade; this process is simplified, because the @ref sm_toolbox "State Machine Toolbox" contains ready-to-use <span class="img initial">Initial Transition</span> tool, which combines an "initial pseudostate" with a transition attached permanently to it. This tool is used to add both the top-most initial transition and initial transitions nested within superstates.


@section sm_initial_add Adding Initial Transition
You select the Initial Transition tool by clicking on the <span class="img initial">button</span> the @ref sm_toolbox "State Machine Toolbox". At this point, when you hover the mouse over the active state diagram, the mouse pointer changes to the initial transition tool. To add an initial transition, move the mouse to the desired location of the **initial pseduostate** of the initial transition and press and hold down the left mouse button. At this point the mouse pointer changes to the initial tran with the  "forbidden" icon (<span class="img forbidden"></span>). Next, you need to **drag** the mouse to an **edge** of the target state. (If you release the mouse button without reaching the target state edge, the QM&trade; tool will delete the transition.) When you drag the mouse pointer over a state edge, the mouse pointer changes to the initial transition with an anchor (<span class="img anchor"></span>), which indicates that you can anchor the end of the initial transition connector at this edge. To anchor the transition, release the mouse button.

@image html "sm_init-add.gif" "Adding Initial Transitions"


@section sm_initial_invalid Invalid Initial Transitions
As you keep working on your state diagram, some initial transition(s) might easily become **invalid**. For example, after resizing of a state the initial pseudostate (black dot) of an initial transition might fall outside of the state shape, might start targeting a non-substate of the parent state, or a state might "acquire" an additional (second) initial transition. Such invalid initial transitions are shown with **dashed line**.

The following animation shows how an initial transition can become invalid and how QM&trade; renders it:

@image html "sm_init-invalid.gif" "Invalid Initial Transition"


@section sm_init_prop Initial Transition Property Sheet
<span class="img initial">Initial Transition</span> item can be configured by the Initial Transition-Specific @ref ui_prop "Property Sheet".

@image html "sm_init_prop.png" "Initial Transition Property Sheet"

The Initial Transition property sheet contains the following properties:
- **target state**  (not editable--determined geometrically)
- @ref bm_init-act


@subsection bm_init-act Initial Transition Action
An Initial Transition can have optional **action**. If defined, the action shows up in the text-box associated with the Initial Transition.

An action is considered defined if the corresponding **pseudocode** or **code** boxes in the @ref sm_init_prop "Initial Transition Property Sheet" are not empty. Once an action is defined, it is shown in the text box associated with the Initial Transition (following the forward-slash `/` character).

@note
The **pseudocode** property is designed to avoid clutter in the diagram by minimizing the amount of text to display beside the transition. **Pseudocode** is intended only for displaying in the diagram and has <span>no implications for code generation</span>. Only the <strong>Code</strong> entry of the *action* property matters for code generation.

@sa @ref sm_tran-text "How QM displays action code in the text box"


@image html "sm_init-text.gif" "Moving and Resizing the Transition Text-Box"

Once the initial transition is *selected* as the @ref ui_curr_item "Current Item", you can **move** and **resize** the text-box by dragging it around or dragging the lower-right handle of the box (see the screen animation above).


@section sm_init-route Routing Transition Path
All transitions in QM&trade; are **rectilinear**, meaning that they consist only of horizontal or vertical segments. You can adjust the position of the horizontal segments by dragging them up or down or the vertical segments by dragging them left and right.

@nav{sm_choice,sm_hist}
*/
/*==========================================================================*/
/*! @page sm_hist Working with Transitions to History
@tableofcontents
@nav{sm_init,sm_subm}

<p>Sometimes in hierarchical state machines you need to transition out of a _composite_ state, but later you wish to come back to the _most-recent_ active substate of this composite state. In UML, this coming back to the most-recent substate is accomplished by the **transition to history** feature. Actually, the UML specification distinguishes between two types of "transition
 to history":
</p>

- **shallow-history** (shown as a circled letter `H`) is a shorthand notation that represents the most recent active direct substate of its containing state. A transition coming into the shallow-history vertex (called a transition to history) is equivalent to a transition coming into the most recently active direct substate of a state.

- **deep-history** (shown as a circled `H*`) is similar to shallow-history except it represents the most recent _leaf_-substate of the composite state.

QM&trade; supports directly the "transition to history" feature for all QP framework types (<span class="img qp_framework">qpc</span>, <span class="img qp_framework">qpcpp</span>, and <span class="img qp_framework">qpn</span>) as well as both @ref sm_class_qhsm "QHsm-style" state machines and @ref sm_class_qmsm "QMsm-style" state machines. Also, starting from version 4.0.0, QM supports both the @ref sm_hist-is_shallow "deep history" transition type denoted as a circled letter `(H+)` and the @ref sm_hist-is_shallow "shallow history" transition type denoted as a circled letter `(H)`.

@image html "sm_hist.png" "Transition to deep history"

In most UML tools, the process of drawing a "transition to history" consists of first adding a history pseudostate (a circle with the letter `H`) and then attaching to it a transition to indicate the **default substate**, before the composite state has ever been visited.

In QM&trade;, however, this process is simplified, because the @ref sm_toolbox "State Machine Toolbox" contains ready-to-use <span class="img history">History Segment</span> tool, which combines a "history pseudostate" with a transition to the "default substate" permanently attached to it.

@note
A UML transition-to-history connector (of any type) can optionally have an outgoing transition pointing to the substate of the composite state. This is the way to designate a _default substate_, when the composite state has no history yet (has never been active before). In UML, the outgoing transition from the history connector is optional, but this leaves the "default substate" unspecified in case when the composite state has no history yet (has never been active before). The QM&trade; tool does **not allow** such incomplete history connectors and therefore the <span class="img history">History Segment</span> tool requires you to always **attach** it to an existing "default substate".


@section sm_hist_add Adding History to a Composite State
You select the History Segment tool by clicking on the <span class="img history">button</span> the @ref sm_toolbox "State Machine Toolbox". At this point, when you hover the mouse over the active state diagram, the mouse pointer changes to the history transition tool. To add a history transition, move the mouse to the **edge** of the desired composite state and press and hold down the left mouse button. At this point the mouse pointer changes to the history tran with the  "forbidden" icon (<span class="img forbidden"></span>). Next, you need to **drag** the mouse to an **edge** of the desired substate of the composite state. (If you release the mouse button without reaching any substate edge, the QM&trade; tool will delete the transition.) When you drag the mouse pointer over a state edge, the mouse pointer changes to the history transition with an anchor (<span class="img anchor"></span>), which indicates that you can anchor the end of the history transition connector at this edge. To anchor the history transition, release the mouse button.

@note
A given composite state can have at most one History Transition at its edge.

@image html "sm_hist-add.gif" "Adding History Transition to a Composite State"

@attention
The QM&trade; tool permits you to attach the <span class="img history">History Segment</span> only to an **edge** of a composite state, as opposed to its interior (as in other UML tools). This is intentional to make transitions to history also available in @ref sm_subm "Submachine Diagrams".

@image html "subm_hist.gif" "History inside a submachine (top) and at the boundary of a submachine state (bottom)"


@section sm_hist_subm Adding History to a Submachine Diagram
History Segment can also be added to a @ref sm_subm "Submachine Diagram" in a similar way as it can be added to a composite state.

@note
Because the <span class="img history">History Segment</span> is attached to the **boundary** of the Submachine, it appears on the **boundary** of all associated @ref sm_smstate "Submachine States" in the same consistent manner as all the @ref sm_epseg "Entry-Points" and @ref sm_xp "Exit-Points". In other words, the *History Segment* becomes part of the Submachine interface.

@image html "sm_hist-subm.png" "History Transition in a Submachine Diagram"

@note
A given *Submachine Diagram* can have at most one History Transition at its **boundary**. The History connector is **not allowed** in any sub-states nested within the submachine, and the QM tool does **not** allow attaching the History connector to the sub-states of a submachine.


@section sm_hist_invalid Invalid History Transitions
As you keep working on your state diagram, some history transition(s) might easily become **invalid**. For example, after resizing of a state the target substate of a history transition might fall outside of the state shape, such that it no longer is a substate of the composite state. Such invalid history transitions are shown with **dashed line**.


@section sm_hist_in Adding Incoming Transition to State History
Once a composite state has a <span class="img history">History Transition</span> at its edge, it can become a target of regular stat transitions. All such transitions will then lead to the history of the composite state. There is no limit on the number of such incoming transitions.

To attach a transition to a given history connector select the desired transition and hover your mouse over its end (this can be either a regular transition <span class="img tran_state"></span>, or an internal transition <span class="img tran_internal"></span>). Once the mouse pointer changes to a hand, you can **drag** the transitin end to the history connector. When you are over the history connector, the cursor changes into a circle with letter 'H' in it. At this point you release the left mouse button to "drop" the transition end on the hitory connector. As mentioned above, you can attach multiple transition ends to a given history connector.

@image html "sm_hist-attach.gif" "Attaching a Transition to History of a Composite State"

To **disconnect** a given transition from a history connector, you first select this transition by clicking on one of its segments. Then, you hover the mouse cursor over the history connector, until it changes into a circle with letter 'H' in it. You can then drag this transition end to a desired new location, which might be an edge to the new target state, or away from any state edge, at which point it becomes an internal transition (see also @ref sm_tran_type "transition type").


@section sm_hist_prop Transition to History Property Sheet
<span class="img history">History Transition</span> item has a simple Property Sheet that currently does not contain any configurable parameters.

@image html "sm_hist_prop.png" "Transition to History Property Sheet"

The Transition to History property sheet contains the following properties:
- @ref sm_hist-target
- @ref sm_hist-is_shallow


@subsection sm_hist-target Target
The **target** property is not editable directly, but rather it is determined geometrically by the end-point of the transition to history. The target property determines the value of the history before the composite state has been visited.


@subsection sm_hist-is_shallow Is Shallow
This **is shallow** property specifies the type of the transition to history. When the checkbox is unchecked, the history transition is to **deep history**, which is indicated by the circled `(H+)`. When the checkbox is checked, the history transition is to **shallow history**, which is indicated by the circled `(H)`.

@nav{sm_init,sm_subm}
*/
/*==========================================================================*/
/*! @page sm_subm Working with Submachine Diagrams
@tableofcontents
@nav{sm_hist,sm_epseg}

<p><span class="img submachine">Submachine Diagram</span> allows you to specify a composite state and all its nested substates and transitions (*submachine*) in such a way that it can be instantiated (and thus reused), possibly **multiple times**, in the context of a given state machine. You can think of submachines as "macros" or "procedures" that capture common behavior inside a given state machine in order to reuse it (as @ref sm_smstate "submachine states") within the context of the same state machines
</p>

@remarks
Some designers try to use *Submachines* as ["orthogonal regions"](https://en.wikipedia.org/wiki/UML_state_machine#Orthogonal_regions). This is **incorrect**, because *Submachines* and their instances (@ref sm_smstate "Submachine States") are **not** concurrently-active parts. A state machine with multiple *Submachine States* can still be in only **one** currently active state configuration ("exclusive-OR"-decomposition).

@note
If you are looking for partitioning your behavior into concurrently active components ("orthogonal components" with [AND-decomposition](https://en.wikipedia.org/wiki/UML_state_machine#Orthogonal_regions)), you should consider the [**Orthogonal Component State Pattern**](https://www.state-machine.com/doc/Pattern_Orthogonal.pdf) instead *Submachines* and *Submachine States*.


To enable reuse of a *Submachine Diagram* without revealing its internal structure ("black-box"), the *Submachine Diagram* must provide a well-defined interface on its boundary, which consists of <span class="img ep_seg"></span> @ref sm_epseg "Entry Points" for attaching
 any incoming transitions targeting specific substates and <span class="img xp"></span> @ref sm_xp "eXit Points" for attaching outgoing transitions originating in specific substates.

@image html "sm_subm.png" "Submachine Diagram"

@attention
The @ref ce "QM code generator" supports Submachine Diagrams only for the @ref sm_class_qmsm "QMsm-style state machine implementation strategy". This means that the class to which you add Submachine Diagram must be a subclass of @ref sm_class "QMsm or QMActive base classes".

<div style="clear:both;"></div>


@section sm_subm_add_blank Adding a Blank Submachine Diagram
To add an new, blank Submachine Diagram, in the @ref ui_explorer **right-click** on the @ref sm_add "State Machine (SM)" to which you want to add the Submachine Diagram and select <span class="img submachine">Add Sub-Machine</span> from the popup menu.

@image html "sm_subm_add.png" "Adding a Submachine to a given State Machine diagram"

@note
In order to add a Submachine Diagram, the State Machine must be @ref bm_lock "unlocked" (<span class="img unlock"></span>).


@section sm_subm_add_state Creating a Submachine Diagram from State
Alternatively, you can create a *Submchine Diagram* from an existing (composite) state. The advantage of this method is that the created Submachine will contain all the internals of the chosen composite state, including the entry actions, exit action, initial transition, as well as all the nested substates and transitions.

To create a new Submachine Diagram from a given state **right-click** on this state in the diagram (or in the @ref ui_explorer) and select <span class="img submachine">Add Sub-Machine from State</span> from the popup menu.

@image html "sm_subm_from_state.png" "Creating a Submachine from a Composite State"


@section sm_subm_resize Resizing a Submachine Diagram
As all diagrams in QM, the *Submachine Diagram* has a @ref bm_diagram_canvas "Drawing Canvas", which can be resized by dragging the outside edges or the bottom-right corner of the diagram. However, the special feature of *Submachine Diagram* is that resizing the canvas always simultaneously resizes the outline of the composite state (shown in green).

@image html "sm_subm_resize.png" "Resizing a Submachine Diagram"


@section sm_subm_delete Deleting a Submachine Diagram
To delete a Submachine Diagram, you need to select it as the @ref ui_curr_item "Current Item", either by clicking on the (green) state outline or in the @ref ui_explorer "Model Explorer". After this, you can delete the Submachine in several ways: (1) click the <span class="img delete">button</span> in the @ref ui_explorer_delete  "Explorer Toolbar"; (2) press the <span class="button">Del</span> keyboard shortcut; or (3) right-click on the state diagram and choose the <span class="menu">Delete item</span> option from the pop-up menu (see the screen animation below).

@note
Deleting a *Submachine Diagram* removes the reference to this *Submachine* in all @ref sm_smstate "Submachine States" based on this Submachine.


@section sm_subm_prop Submachine Diagram Property Sheet
<span class="img state">Submachine Diagram</span> item can be configured by the State-Specific @ref ui_prop "Property Sheet".

@image html "sm_subm_prop.png" "State Property Sheet"

The state-item property sheet contains the following properties:

- @ref sm_subm-name
- @ref sm_subm-doc
- @ref sm_subm-entry
- @ref sm_subm-exit


@subsection sm_subm-name Submachine Name
The submachine **name** should be a valid function name in C or C++. Typically, you should strive for a short and punchy name that captures the nature of the submachine. For example, a submachine in which a system remains "on" could be named `on`. To keep with the naming conventions used in @ref gs_exa "QM examples", it is recommended to name use lower-case names of submachines.


@subsection sm_subm-doc Submachine Documentation
The **documentation** entry in the Submachine Property Sheet allows you to provide documentation to the submachine. The QM code generator parses the documentation text and can @ref ce_comment-doc "generate comments" from it in the auto-generated code.


@subsection sm_subm-entry Submachine Entry Action
A submachine can have optional **entry action**. You provide this action in the @ref sm_subm_prop "Submachine Property Sheet" (see also the screen shot above). If defined, the entry action shows up in the upper-left corner of the submachine outline. The Submachine entry action behaves in exactly the same way as the @ref sm_state-entry "entry action to a state".

@note
Once the state shape is *selected* as the @ref ui_curr_item "Current Item", you can **resize the entry box** by dragging the lower-right handle of the box.


@subsection sm_subm-exit Submachine Exit Action
A submachine can have optional **exit action**. You provide this action in the @ref sm_subm_prop "Submachine Property Sheet" (see also the screen shot above). If defined, the exit action shows up in the upper-left corner of the submachine outline (below the entry action, if present). The Submachine exit action behaves in exactly the same way as the @ref sm_state-exit "exit action to a state".

@note
Once the state shape is *selected* as the @ref ui_curr_item "Current Item", you can **resize the exit box** by dragging the lower-right handle of the box.

@nav{sm_hist,sm_epseg}
*/
/*==========================================================================*/
/*! @page sm_epseg Working with Entry-Point Segments
@tableofcontents
@nav{sm_subm,sm_xp}

<p><span class="img ep_seg">Entry-Point Segment</span> represents a way of transitioning into a specific substate of a @ref sm_subm "Submachine". The *Entry-Point* provides an indirection layer to entering a specific substate without exposing this substate or any other internal parts of the Submachine.
</p>

<div style="clear:both;"></div>

@image html "sm_epseg.png" "Entry-Point Segment in a Submachine"

In most UML tools, the process of drawing entry-point transitions consists of first adding an Entry-Point pseudostate (empty circle) and then attaching a transition between it and some state. In QM&trade; this process is simplified, because the @ref sm_toolbox "Submachine Toolbox" contains ready-to-use <span class="img ep_seg">Entry-Point Segment</span> tool, which combines an "Entry-Point pseudostate" with a transition attached permanently to it.


@section sm_epseg_add Adding Entry-Point Segment
You select the Entry-Point Segment tool by clicking on the <span class="img ep_seg">Entry-Point button</span> the @ref sm_toolbox "State Machine Toolbox". At this point, when you hover the mouse over the active submachine diagram, the mouse pointer changes to the EP-segment tool. To add an Entry-Point segment, move the mouse to the desired location of the **Entry-Point pseduostate** of the Entry-Point segment and press and hold down the left mouse button. At this point the mouse pointer changes to the Entry-Point segment with the  "forbidden" icon (<span class="img forbidden"></span>). Next, you need to **drag** the mouse to an **edge** of the target state. (If you release the mouse button without reaching the target state edge, the Entry-Point segment will be deleted.) When you drag the mouse pointer over a state edge, the mouse pointer changes to the Entry-Point segment with an anchor (<span class="img anchor"></span>), which indicates that you can anchor the end of the Entry-Point segment connector at this edge. To anchor the segment, release the mouse button.


@section sm_epseg_prop Entry-Point Segment Property Sheet
<span class="img ep_seg">Entry-Point Segment</span> item can be configured by the Entry-Point Segment @ref ui_prop "Property Sheet".

@image html "sm_epseg_prop.png" "Entry Point Segment Property Sheet"

The Initial Transition property sheet contains the following properties:
- @ref sm_epseg-name
- **target**  (not editable--determined geometrically)
- @ref sm_epseg-act


@subsection sm_epseg-name Entry-Point Name
Every Entry-Point segment must have a name, which distinguishes this particular Entry-Point from other Entry-Points to the same Submachine. The Entry-Point name should be a valid function name in C or C++. Typically, you should strive for a short and punchy name that captures the nature of the state entered directly by the Entry-Point. The Entry-Point name shows up in the first Text Box associated with the Entry-Point.


@subsection sm_epseg-act Entry-Point Segment Action
An Entry-Point segment can have optional **action**. If defined, the action shows up in the text-box associated with the Entry-Point segment.

An action is considered defined if the corresponding **pseudocode** or **code** boxes in the @ref sm_epseg_prop "Entry-Point Segment Property Sheet" are not empty. Once an action is defined, it is shown in the text box associated with the Entry Point segment (following the forward-slash `/` character).

@note
The **pseudocode** property is designed to avoid clutter in the diagram by minimizing the amount of text to display beside the transition. **Pseudocode** is intended only for displaying in the diagram and has <span>no implications for code generation</span>. Only the <strong>Code</strong> entry of the *action* property matters for code generation.

@sa @ref sm_tran-text "How QM displays action code in the text box"

@nav{sm_subm,sm_xp}
*/
/*==========================================================================*/
/*! @page sm_xp Working with eXit-Points
@tableofcontents
@nav{sm_epseg,sm_smstate}

<p><span class="img xp">eXit Point</span> represents a specific transition out of the *Submachine Diagram*. The *eXit-Point* provides an indirection layer to exiting a specific substate without exposing this substate or any other internal parts of the Submachine.
</p>


@section sm_xp_add Adding eXit-Point
You select the eXtry-Point tool by clicking
 on the <span class="img xp">eXit-Point button</span> the @ref sm_toolbox "State Machine Toolbox". At this point, when you hover the mouse over the active submachine diagram, the mouse pointer changes to the XP tool. To add an eXit-Point, move the mouse to the desired location of the **eXit-Point** on the **boundary** of the *Submachine Diagram*. At this point the mouse pointer changes to the eXit-Point with an anchor (<span class="img anchor"></span>), which indicates that you can anchor the eXit-Point at this edge. To anchor the point, release the mouse button.


@section sm_xp_prop eXit-Point Property Sheet
<span class="img xp">eXit-Point</span> item can be configured by the eXit-Point @ref ui_prop "Property Sheet".

@image html "sm_xp_prop.png" "eXit Point Property Sheet"

The Initial Transition property sheet contains the following properties:
- @ref sm_xp-name


@subsection sm_xp-name eXit-Point Name
Every eXit-Point must have a name, which distinguishes this particular eXit-Point from other eXit-Points from the same Submachine. The eXit-Point name should be a valid function name in C or C++. Typically, you should strive for a short and punchy name that captures the nature of the state exited by the eXit-Point. The eXit-Point name shows up in the Text Box associated with the eXit-Point.

@nav{sm_epseg,sm_smstate}
*/
/*==========================================================================*/
/*! @page sm_smstate Working with Submachine States
@tableofcontents
@nav{sm_xp,sm_xpseg}

<p><span class="img sm_state">Submachine State</span> represents an instance of a given @ref sm_subm "Submachine Diagram" and is semantically equivalent to inserting the whole *Submachine Diagram* in a given place of your state machine.
</p>

@remarks
Some designers try to use *Submachine States* as ["orthogonal regions"](https://en.wikipedia.org/wiki/UML_state_machine#Orthogonal_regions). This is **incorrect**, because *Submachine States* are **not** concurrently-active parts. A state machine with multiple *Submachine States* can still be in only **one** currently active state configuration ("exclusive-OR"-decomposition).

@note
If you are looking for partitioning your behavior into concurrently active components ("orthogonal components" with [AND-decomposition](https://en.wikipedia.org/wiki/UML_state_machine#Orthogonal_regions)), you should consider the [**Orthogonal Component State Pattern**](https://www.state-machine.com/doc/Pattern_Orthogonal.pdf) instead *Submachines* and *Submachine States*.


Each *Submachine State* represents a distinct instance of a @ref sm_subm "Submachine", even when multiple *Submachine States* reference the same *Submachine*, such as "operand1" and "operand2" Submachine States both reference Submachine "operand" in the picture below:

@image html "sm_smstate.png" "Submachine State instances"

A *Submachine State* presents the interface defined in the @ref sm_smstate-subm "associated Submachine". This interface consists of <span class="img ep_seg"></span> *Entry Points* to be used as targets for transitions to specific substates and <span class="img xp"></span> *eXit Points* for attaching <span class="img xp_seg"></span> @ref sm_xpseg "eXit Point Segments".

A *Submachine State* can have also @ref sm_tran "incoming transition" that terminate on the boundary of the *Submachine State* and don't target any Entry-Points. Such incoming transitions enter the associated Submachine through its initial transition (if available).

Finally, a *Submachine State* can have @ref sm_tran "outgoing transitions" that don't originate on any of its Exit-Points. Such outgoing transitions are unique to this particular *Submachine State*.

@note
A *Submachine State* cannot have nested states. The entire internal structure of the Submachine State is determined by the associated @ref sm_subm "Submachine".

@attention
All <span class="img xp"></span> @ref sm_xp "eXit-Points" of a *Submachine State* must be connected to <span class="img xp_seg"></span> @ref sm_xpseg "eXit-Point Segments". Otherwise the @ref ce "QM Code Generator" will report errors.


@section sm_smstate_add Adding a Submachine State
@note
In order to add a submachine state, you first need to @ref sm_add "create" and @ref bm_diagram_open "show" a state diagram. Also, to add, move, resize, or edit states, the State Machine diagram must be @ref bm_lock "unlocked" (<span class="img unlock"></span>).

Make sure that the State Machine subwindow is active. In the @ref sm_toolbox click on the <span class="img sm_state">Submachine State</span> tool and *release* the mouse button (don't drag the tool off the toolbar). At this point, when you hover the mouse over the active state diagram, the mouse pointer changes shape to the <span class="img cur_state1">state</span> tool. To add a state, move the mouse to the desired location of the **top-left corner** of the state shape and press the left mouse button. At this point you create a state shape of minimal size at the mouse position. You can release the mouse button immediately or you can **drag** the mouse to the desired location of the **bottom-right** corner of the state shape. In any case, you can @ref sm_state_resize "resize" the state shape at any later time.


@section sm_smstate_move Moving a Sumachine State
To move a submachine state, hover the mouse over the state until you get the move cursor. Click the mouse and drag the state shape to the desired location.


@section sm_smstate_resize Resizing a Submachine State
You can resize all four edges of a submachine state shape. The top and bottom edges can be resized up and down, while left and right edges can be resized left and right. Additionally, the right-bottom corner can be resized diagonally (i.e., both horizontally and vertically).

To resize the desired edge of a submachine state, hover the mouse over the state edge until you get the resize cursor. Click the mouse and drag the state edge to the desired location.


@section sm_smstate_delete Deleting a Submachine State
To delete a submachine state, you need to select it as the @ref ui_curr_item "Current Item", either by clicking on it in the state diagram or in the @ref ui_explorer "Model Explorer". After this, you can delete the submachine state in several ways: (1) click the <span class="img delete">button</span> in the @ref ui_explorer_delete  "Explorer Toolbar"; (2) press the <span class="button">Del</span> keyboard shortcut; or (3) right-click on the state diagram and choose the <span class="menu">Delete item</span> option from the pop-up menu.


@section sm_smstate_prop Submachine State Property Sheet
<span class="img sm_state">Submachine State</span> item can be configured by its specific @ref ui_prop "Property Sheet".

@image html "subm_state_prop.png" "Submachine State Property Sheet"

The Submachine-State item property sheet contains the following properties:

- @ref sm_smstate-name
- @ref sm_smstate-subm
- @ref sm_smstate-doc


@subsection sm_smstate-name Submachine State Name
The Submachine State **name** should be a valid function name in C or C++. Typically, you should strive for a name that captures the nature of the Submachine State and is somehow related to the instantiated @ref sm_subm "Submachine Diagram". For example, a submachine state that instantiates "Submachine Diagram" named "operand" could be named "operand1". To keep with the naming conventions used in @ref gs_exa "QM examples", it is recommended to name use lower-case names of submachine states.


@subsection sm_smstate-subm Submachine
The **submachine** property associates the *Submachine State* with the given @ref sm_subm "Submachine Diagram". This property is editable via a drop-down box, which contains all *Submachine Diagrams* defined for this state machine.


@subsection sm_smstate-doc Documentation
The **documentation** entry in the Submachine State Property Sheet allows you to provide documentation to the submachine state. The QM code generator parses the documentation entry and can @ref ce_comment-doc "generate comments" from it in the auto-generated code.

@nav{sm_xp,sm_xpseg}
*/
/*==========================================================================*/
/*! @page sm_xpseg Working with eXit-Point Segments
@tableofcontents
@nav{sm_smstate,ce}

<p><span class="img xp_seg">eXit-Point Segment</span> represents a way of transitioning out of a specific substate of a @ref sm_subm "Submachine". The *eXit-Point* provides an indirection layer to exiting a specific substate without exposing this substate or any other internal parts of the Submachine.
</p>

@note
An *eXit-Point Segment* is like a @ref sm_tran "transition", except it does **not have a trigger**. Also, similarly to a state transition, an *eXit-Points* might not target any state, in which case it behaves as an internal transition.

![eXit-Point Segments](sm_xpseg.png)


@section sm_xpseg_add Adding an eXit-Point Segment

@note
In order to add a transition, you first need to @ref bm_diagram_open "open" a state diagram, which needs to have at least one @ref sm_state "state". Also, the State Machine diagram must be @ref bm_lock "unlocked" ( <span class="img unlock"></span>).

Make sure that the State Machine subwindow is active. In the @ref sm_toolbox click on the <span class="img xp_seg">eXit-Point Segment</span> tool and *release* the mouse button (don't drag the tool off the toolbar). At this point, when you hover the mouse over an eligible *eXit-Point* of a @ref sm_smstate "Submachine State", the mouse pointer changes to the eXit-Point Segment tool with the anchor (<span class="img anchor"></span>). To add the eXit-Point Segment at this **source** state, press the mouse button and drag the transition end out. As you drag the connector, the mouse pointer changes to a hand and the transition end takes the shape of a square (<span class="img tran_internal"></span>).


@section sm_xpseg_choice eXit-Point Segment with Choices
An eXit-Point Segment, just like a @ref sm_tran "state transition", might have @ref sm_choice "choice segments" attached to its end. However, an important limitation for eXit-Point Segments is that the choices must be **complementary**, meaning that you must use the @ref sm_choice_else "else guard" to complement any other choices attached to the end of an eXit-Point Segment. For example, the screen shot below shows an eXit-Point Segment with complementary choice segments:

![eXit-Point Segment with complementary choice segments](sm_xpseg_choice.png)

@note
The failure to use complementary guards at the end a eXit-Point Segment results in a code-generation **ERROR C113** "exit-point with non-complementary guards"

![eXit-Point Segment with non-complementary choice segments](sm_xpseg_err.png)


@section sm_xpseg_prop eXit-Point Property Sheet
<span class="img xp_seg">eXit-Point Segment</span> item can be configured by the eXit-Point Segment @ref ui_prop "Property Sheet".

@image html "sm_xpseg_prop.png" "eXit-Point Segment Property Sheet"

The eXit-Point Segment property sheet contains the following properties:
- @ref sm_xpseg-xp (not editable--determined geometrically)
- @ref sm_xpseg-target (not editable--determined geometrically)
- @ref sm_xpseg-act


@subsection sm_xpseg-xp Associated eXit-Point
The **eXit-Point** property is not editable directly, but rather it is determined geometrically by the @ref sm_xp "eXit-Point" at which the given eXit-Point Segment originates.


@subsection sm_xpseg-target eXit-Point Segment Target
The **target** property is not editable directly, but rather it is determined geometrically by the end-point of the transition. For *state-to-state transitions*, the *target* property lists the target state at which the end-point (<span class="img tran_state"></span>) terminates. For *internal transitions* with the square end-point (<span class="img tran_internal"></span>), the *target* property shows `internal`.


@subsection sm_xpseg-choice eXit-Point Segment with Choice Segments


@subsection sm_xpseg-act eXit-Point Segment Action
An *eXit-Point Segment* can have optional **action** property, which consists of two entries: *pseudocode* and *code* (see @ref sm_tran_prop "Transition Property Sheet"). Only the **code** part of the *action* property is relevant for the @ref ce "code generation". The **pseudocode** field is designed only to be displayed in the diagram to avoid clutter by minimizing the amount of text to display next to the transition shape.

@attention
The <strong>Pseudocode</strong> entry of the *action* property is intended only for displaying in the diagram and has <span>no implications for code generation</span>. Only the <strong>Code</strong> entry of the *action* property matters for code generation.

@sa Refer to the documentation for @ref sm_tran "State Transition" for information how to route the eXit-Point Segment, change its type (state-to-state vs. internal), and how to move and resize its action Text Box.

@nav{sm_smstate,ce}
*/

