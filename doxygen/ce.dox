/*! @page ce Code Engineering
@tableofcontents
@nav{sm_xpseg,ce_dir}

@anchor idx_ce
<p> **Code engineering** is the process of designing, implementing, and maintaining source code. This section describes how QM&trade; can assist you in this process by providing a unique approach to modeling the structure and content of the **generated source code**, also known as the "physical design" as defined below:
</p>

@note **Physical design** is the decomposition of the source code into directories and files, such as header files (`.h` files) and implementation files (`.c` or `.cpp` files), as well as "makefiles", build scripts, etc. The critical aspect of physical design is managing the inter-dependencies among the source code modules, as well as an information hiding policy to expose only the desired interfaces in the header files. Additionally, physical design of automatically generated source code must also afford a sufficiently flexible way of interfacing with hand-crafted code or any existing 3rd-party code.


@section ce_phys Physical Design
In QM&trade;, directories and files are first-class model elements, so the **physical design** is an integral part of the model, just as the logical design is. This approach makes QM&trade; a unique tool on the market that allows you to **explicitly** perform physical design of the generated code as an integral part of the modeling process (as opposed to tweaking the code generator or adjusting hundreds of parameters of a "model compiler").

@remark
If you have used other modeling tools, the QM&trade; approach might feel like <a class="extern" target="_blank" href="http://embeddedgurus.com/state-space/2012/02/turning-automatic-code-generation-upside-down/">turning code generation "upside down"</a>, because QM&trade; does not impose any code structure by itself, but rather gives **you** the complete control of what is being generated. In contrast, most other modeling tools on the market use an implicit and inflexible physical design, in which, for example, each @ref bm_class "class" generates a `<class-name>.h` header file and `<class-name>.c/.cpp` implementation file.

@anchor ce_temp
The main enabler of the explicit physical design is representing directories and files as *model items* that can be added to the model and edited as any other parts of the model. But, it is critical to understand that the @ref ce_dir "directories" and @ref ce_file "files" in the model are **not** the actual directories and files on disk. Rather, you should think of these model items as "templates" that the QM&trade; code generator uses to create the actual directories and files on your disk. (The word "template" here should not be confused with the "C++ templates"!)

@note
QM&trade; supports also @ref ce_file_extern "External Files", which combine the user-provided code with sections of generated-code. This merging of a file-template with generated-code is achieved by clearly delimiting the generated-sections with special comments. Such *External Files* can be edited inside any editor/IDE of choice and are **not** editable inside QM.


The following picture shows an example of a directory-"template" and some file-"templates" in QM&trade;. The file-"template" is shown both in the @ref ui_explorer and in the @ref ui_mdi "MDI" window:

@image html ce_phys.png "Directory and file @"templates@" in a QM model"

The following picture shows how the directory-"template" and file-"templates" in the model generate the physical directory and files on disk. The code generation process is depicted as arrows from the model items to the files on disk.

@image html ce_disk.png "Code generation uses the directory and file templates to create directories and files on disk"

@note
The model items for modeling directories and files were called in this section directory-"template" and file-"template", respectively, so that you can get used to distinguishing the model items from the physical directories and files on your disk. In the following sections, however, the model items will be simply referred to @ref ce_dir "directories" and @ref ce_file "files", with the understanding that a model can hold only the "templates" for directories and files.


@section ce_misra MISRA Compliance
The parts of code generated by QM&trade; are compliant with the <a class="extern" target="_blank" href="http://www.misra.org.uk/">Motor Industry Software Reliability Association (MISRA) Guidelines</a>. Specifically, the QM code generator for the <strong>C</strong> language emits code compliant with the <a class="extern" target="_blank" href="http://www.misra.org.uk/Publications/tabid/57/Default.aspx#label-c2">MISRA C:2004</a> and the QM code generator for the <strong>C++</strong> language emits code compliant with the <a class="extern" target="_blank" href="http://www.misra.org.uk/Publications/tabid/57/Default.aspx#label-cpp">MISRA C++:2008</a>.

@note
Of course, the compliance with any coding standard, such as MISRA, can be guaranteed only for parts of code actually created by the tool. The other parts of the code, such as code copied from the @ref ce_file "file-templates" or action code attached to @ref sm "state machines", is provided externally to the tool. Such code might not be compliant with the MISRA rules.


The other code engineering tasks described in this section include:

- @subpage ce_dir
- @subpage ce_file
- @subpage ce_directive
- @subpage ce_sm
- @subpage ce_comment
- @subpage ce_cond
- @subpage ce_qmc

@nav{sm_xpseg,ce_dir}
*/
/*##########################################################################*/
/*! @page ce_dir Working with Directories
@tableofcontents
@nav{ce,ce_file}

<p>QM&trade; provides special <span class="img folder">directory</span> items to represent directories on the disk. These directory items can be added to the @ref bm_model "model item", to any @ref bm_package "package item", as well as to other directory item in which case you can create nested directories.
</p>
<div style="clear:both;"></div>


@section ce_dir_add Adding a New Directory
To add a new directory item, in the @ref ui_explorer **right**-click on the <span class="img model">model</span> item, a <span class="img package">package</span> item, or <span class="img folder">directory</span> item and select the "Add Directory" in the popup menu, as shown below:
</p>

@image html ce_dir_add.png "Adding directory item to the model item"


@section ce_dir_prop Directory Property Sheet
The only editable attribute in the Directory Property Sheet is the **path** relative to the @ref ui_model_file.

@image html ce_dir_name.png "Directory Item Property Sheet"


@section ce_dir_path Setting the Directory Path


@subsection ce_dir_package Directories Inside the Model or a Package
The path of a directory nested directly inside the <span class="img model">model</span> item is <span class="highlight"> **relative** to the location of the @ref ui_model_file "model file" on your disk</span>. The path of a directory nested inside a <span class="img package">package</span> item is:
- <span class="highlight"> **relative** to the location of the @ref ui_model_file "model file"</span> for directories nested inside @ref bm_package "regular packages"
- <span class="highlight"> **relative** to the location of the @ref bm_package-extern "package file"</span> for directories nested inside @ref bm_package-extern "external packages"


In any case, the directory path is always **relative**. This relative path can contain the usual relative path symbols, such as the current model directory, denoted as `.` (dot), parent directory of the model as `..` (dot-dot), etc. The following table shows some examples of the relative paths for the model-level or package-level directory items:

<center>
Directory Path Example                          |  Path (Windows) | Path (Unix)
:-----------------------------------------------|:----------------|:-----------
the model directory                             | `.`             | `.`
subdirectory `code` of the model directory      | `code`          | `code`
parent directory of the model directory         | `..`            | `..`
sibling directory `proj` of the model directory | `..\proj`       | `../proj`
</center>

@note
The directory path can use the native directory separator on the platform where QM&trade; runs, such as `\` (backslash) on Windows and `/` (forward slash) on Linux. Alternatively, on any platform the directory path can use the `/` (forward slash) directory separator.


@subsection ce_dir_nest Nested Directories
The path of a directory nested inside another <span class="img folder">directory</span> item is simply the name of that directory, while the natural nesting of the directory items in the model determines the nesting of the directories created on the disk.

@note
The path of a directory nested inside a directory cannot contain directory separators or any relative path symbols, like `.` or `..`.

For example, the following screen shot shows directories `subproj1` and `subproj2` nested inside the directory `..\proj`. Please note that the path of the package-scope directory `..\proj` is relative to the model file on the disk, while the paths of `subproj1` and `subproj2` are simply the names of these directories.


@image html ce_dir_nest.png "Nested directories inside a project-scope directory"


@section ce_dir_drag Drag-and-Drop
Once you have some directory items added to your model, you can use the drag-and-drop support in the @ref ui_explorer to move the <span class="img folder">directory</span> items from one allowed location to another in the Model Explorer tree view.

@nav{ce,ce_file}
*/
/*##########################################################################*/
/*! @page ce_file Working with Files
@tableofcontents
@nav{ce_dir,ce_directive}

<p>As described in the section about the @ref ce_phys "physical design", QM&trade; provides special <span class="img file">file items</span> that represent files to be generated on disk. The file items can only exist inside a @ref ce_dir "directory item", which determines the location of the file relative to the @ref ui_model_file "QM Model File" or the @ref bm_package-extern "External Package File", for files nested inside External Packages.
</p>


@section ce_file_intern Internal Files
Normally, the <span class="img file">file items</span> are just "templates" for the files to be created on disk. Such file-templates are called **internal files** and can be edited in the @ref ui_mdi "MDI windows" at the center of the @ref ui "QM user interface", which work exactly like any other modern @ref bm_edit "code editors".

You can insert any code (or text) into the file-templates, such as #`include` directives, declarations, definitions, comments, and anything else that you would put into hand-crafted code. All this code will then be literally copied over to the files generated on disk. But, the twist here is that you can also direct QM to **generate** specific parts of the code based on the model items of your choosing, with the granularity ranging from @ref bm_package "packages" and @ref bm_class "classes", down to specific @ref sm "state machines", @ref sm_state "states", @ref bm_attr "attributes", and @ref bm_oper-class "operations".

<div style="clear:both;"></div>

@image html ce_file_gen.png "QM Code Generation as Expansion of Code-Generation Directives"


You achieve this by inserting the special @ref ce_directive "Code-Generation Directives" into your file-templates. For example, you can direct QM to generate a class @ref ce_directive-decl "declaration" in one place of a file on disk, a class @ref ce_directive-def "definition" in another place, and so on.

@attention
The files generated from *Internal Files* should **not** be edited manually outside the QM&trade; tool, because the whole body of the file will be re-generated and any edits would be lost. Therefore, to prevent inadvertent change of the files generated on disk, these files are saved as <span class="highlight"><b>read-only</b></span>.


@section ce_file_extern External Files
QM also supports *External Files*, which combine user-code with the generated-code and possibly @ref ce_directive "Code-Generation Directives". This merging of a file-template with generated-code is achieved by clearly delimiting the generated-sections with special comments. Such External Files can be edited inside any editor/IDE of choice and are **not** editable inside QM. The following listing shows an example of an *External File* on disk (the comments after the listing explain the interesting lines of code):

@includelineno file_external.cpp


<ul class="tag">
  <li><span class="tag">1-21</span> @ref ce_comment-file "Top-level file comment" generated by QM.@n
<span class="highlight"><b>NOTE:</b> This code (between the `$file${..} vvvvvv` and `$endhead${..} ^^^^^^^` should **not** be edited manually.</span>
  </li>
  <li><span class="tag">22-25</span> user-code (editable)
  </li>
  <li><span class="tag">26</span> @ref ce_directive "code-generation directive" (editable)
  </li>
  <li><span class="tag">27-33</span> user-code (editable)
  </li>
  <li><span class="tag">34-61</span> code generated by QM by expanding the directive `$define${SMs::Calc}`@n
<span class="highlight"><b>NOTE:</b> This code (between the `$define${..} vvvvv` and `$enddef${..} ^^^^^^^^` should **not** be edited manually.</span>
  </li>
</ul>

@attention
The files generated from *External Files* are saved as <span class="highlight"><b>writable</b></span>, because the user can edit parts of these files. However, the generated sections delimited between the comments `"$...vvv"` and `"$end...^^^"` should **not** be edited, because they will be re-generated and any edits in these sections would be lost.


@section ce_file_add Adding a New File
The file items can only exist inside a @ref ce_dir "directory item", which determines the location of the file **relative to** the @ref ui_model_file. Therefore, to add a new file item, you first need to select the @ref ce_dir "directory item" in the @ref ui_explorer. Then **right**-click on this <span class="img folder">directory</span> item and select the "Add File" in the popup menu, as shown below:

@image html ce_file_add.png "Adding a file item to a directory item"


@section ce_file_prop File Property Sheet
The following picture shows the Property Sheet of a File Item (see @ref ui_prop):

@image html ce_file_prop.gif "File Item Property Sheet"


@subsection ce_file-name File Name
The most important property of a file item is its **name**. QM&trade; automatically recognizes several file types based on the file name **extension** and applies a special icon for the recognized files. The following table shows the list of recognized file types and icons:

<center>
File Name Extension|  File Type | File Icon
:------------------|:-----------|:----------:
`.h`               | C/C++ header file | <span class="img file_h">&nbsp;</span>
`.hpp`             | C++ header file | <span class="img file_h">&nbsp;</span>
`.c`               | C implementation file | <span class="img file_c">&nbsp;</span>
`.cpp`             | C++ implementation file | <span class="img file_cpp">&nbsp;</span>
`.cxx`             | C++ implementation file | <span class="img file_cpp">&nbsp;</span>
`.cc`              | C++ implementation file | <span class="img file_cpp">&nbsp;</span>
`.ino`             | Arduino sketch | <span class="img file_ino">&nbsp;</span>
`.py`              | Python script  | <span class="img file_py">&nbsp;</span>
`.tcl`             | Tcl/Tk script  | <span class="img file_tcl">&nbsp;</span>
`.mak`             | make file | <span class="img file_mak">&nbsp;</span>
`makefile`         | make file | <span class="img file_mak">&nbsp;</span>
`Makefile`         | make file | <span class="img file_mak">&nbsp;</span>
</center>


@note
Providing one of the recognized file name extensions is necessary for QM&trade; to be able to apply the correct **syntax highlighting** for the file type. The file name extensions are case-sensitive.


@subsection ce_file-encoding Encoding
The **encoding** drop-box property of the file item allows you to select one of the few dozens of available <a class="extern" target="_blank" href="http://en.wikipedia.org/wiki/Character_encoding">character encodings</a> for your file. This option might be interesting if you use special characters outside the basic ASCII character set. (NOTE: the *default* setting corresponds to the encoder selected in your operating system.)


@subsection ce_file-external External
The "external" check box designates a file as an @ref ce_file_extern "External File" that is **not** managed by QM, but still participates in the code generation. Such "external" files can be edited with an editor/IDE of choice.


@section ce_file_eol Unix End-Of-Line Convention
QM&trade; applies consistently the <a class="extern" target="_blank" href="http://en.wikipedia.org/wiki/Newline"><strong>Unix end-of-line convention</strong></a> (single LF octet at the end of line) to all files saved on disk, regardless of the host operating system. This is done intentionally to generate **identical** code across diverse hosts, which might be used by various team members working on the same project.

@note
Because the LF-only end-of-line convention is **nonnative** on Windows, the generated files might look incorrect in some text editors (e.g., <a class="extern" target="_blank" href="http://en.wikipedia.org/wiki/Notepad_%28software%29">Notepad</a>). However, experience shows that most programming editors designed for editing code should have no problem correctly displaying the generated code.

@nav{ce_dir,ce_directive}
*/
/*##########################################################################*/
/*! @page ce_directive Code-Generation Directives
@tableofcontents
@nav{ce_file,ce_declare}

<p>The QM&trade; code generation process consists of replacing the **code-generation directives** in the @ref ce_file "file templates" in the model with the corresponding pieces of auto-generated code in the files generated on disk. All other code fragments surrounding the code-generation directives in the file-templates are simply copied to the files on disk. The picture below illustrates the process:
</p>
<div style="clear:both;"></div>

@image html ce_file_gen.png "QM Code Generation as Expansion of Code-Generation Directives"


@section ce_decl-def Declarations versus Definitions
To work effectively with the *code-generation directives* in QM&trade;, you need to understand the
difference between **declarations** and **definitions** in C or C++.


@subsection ce_directive-decl Declaration
A **declaration** introduces an identifier and describes its type, be it a type name (struct/class/typedef), object (variable), or a function. A declaration is what the C or C++ compiler needs to accept references to that identifier. These are declarations:

@code{.c}
extern int bar;
extern int g(int, int);
double f(int, double); // extern can be omitted for function declarations
class foo; // forward declaration
class bar { bar(); ... }; // no extern allowed for class declarations
@endcode

@note
The QM&trade; code generator applies the keyword `extern` only for declarations of variables.


@subsection ce_directive-def Definition
A **definition** actually instantiates/implements the identifier. It's what the linker needs in order to link references to those entities. These are definitions corresponding to the above declarations:

@code{.c}
int bar;
int g(int lhs, int rhs) {return lhs*rhs;}
double f(int i, double d) {return i+d;}
bar::bar() {};
@endcode

@note
In C and C++ a definition can be used in the place of a declaration, meaning that a definition also provides the type information that the compiler needs to accept references to the defined identifier.


@section ce_directive-syntax General Syntax
The general syntax of the code-generating directives in the QM file templates is <strong>$&lt;directive&gt; ${&lt;model-item&gt;}</strong>, where $&lt;directive&gt; is one of:

- @subpage ce_declare "$declare"
- @subpage ce_define  "$define"
- @subpage ce_define1 "$define1"

and <strong>&lt;model-item&gt;</strong> denotes a @ref bm_fq-name "Fully-Qualified Name" of the model item to expand.

@note
The QM tool supports two alternative versions of the code-generating directives:@n
the old syntax: <strong>$&lt;directive&gt;(&lt;model-item&gt;)</strong>;@n
and the new (recommended) syntax: <strong>$&lt;directive&gt;${&lt;model-item&gt;}</strong>


The use of @ref bm_fq-name "Fully-Qualified Item Names" is necessary to unambiguously identify model items for code generation. For example, a class `Ship` residing inside the package `AOs` will be specified inside a code-generating directive as `AOs::Ship`.

@image html ce_gen-exa.png "Example of $declare${} and $define${} Directives"


@section ce_drag-n-drop Creating Fully-Qualified Names by Drag-n-Drop
Such fully-qualified item names can be, of course, typed by hand in the QM file templates. However, to avoid errors, the @ref ui_explorer allows you to **drag-n-drop** a model item onto a file-template to create a fully-qualified item name, as illustrated in the animation below:

@image html ui_explorer_drag-link.gif "Creating a Fully-Qualified Item Name by Drag-n-Drop"

@note
The code-generation directives are recognized by the **QM syntax highlighter** and are shown in red color and underlined in the @ref bm_edit "QM Code Editors".

@nav{ce_file,ce_declare}
*/
/*##########################################################################*/
/*! @page ce_declare $declare${}
@tableofcontents
@nav{ce_directive,ce_define}

<p>The <strong>$declare${&lt;model-item&gt;}</strong> directive requests generating a **declaration** of the &lt;model-item&gt; specified between the parentheses. QM can generate declarations for the following item types: @ref bm_class "Class", @ref bm_attr-free "Free Attribute", @ref bm_oper-free "Free Operation", and @ref bm_package "Package".
</p>
<div style="clear:both;"></div>

@image html ce_gen-class.png "Example of a Class with a State Machine"


@section ce_declare_class_cpp Class Declaration in C++
In C++, the directive `$declare${<Class>}` generates the C++ class declaration, which has a generic form `class <Class> : public <Superclass> {...};`. For instance, the code snippet below shows the code generated by the directive `$declare${AOs::Ship}` for the class `AOs::Ship` shown in the screen shot above:

@code{.numbered}
//${AOs::Ship} ...............................................................
class Ship : public QP::QMActive {
private:
    uint8_t m_x;
    uint8_t m_y;
    uint8_t m_exp_ctr;
    uint16_t m_score;

public:
    Ship();

protected:
    static QP::QState initial(Ship * const me, QP::QEvt const * const e);
    static QP::QState active  (Ship * const me, QP::QEvt const * const e);
    static QP::QState active_i(Ship * const me);
    static QP::QMState const active_s;
    static QP::QState parked  (Ship * const me, QP::QEvt const * const e);
    static QP::QMState const parked_s;
    static QP::QState flying  (Ship * const me, QP::QEvt const * const e);
    static QP::QState flying_e(Ship * const me);
    static QP::QMState const flying_s;
    static QP::QState exploding  (Ship * const me, QP::QEvt const * const e);
    static QP::QState exploding_e(Ship * const me);
    static QP::QMState const exploding_s;
};
@endcode

@note
A class with a @ref sm "State Machine", such as `Ship` in the example above, contains also the (`static`) member functions and (`static`) attributes for each @ref sm_state "State" of the *state machine*. These elements are specific to the state machine implementation strategy, which in this case is based on the `QMsm` base class from the <a class="extern" target="_blank" href="https://www.state-machine.com/products/qp/">QP/C++ framework</a>.


@section ce_declare_class_c-extern Class Declaration in C (Header File)
In C, the directive `$declare${<Class>}` generates the C "class" declaration, which consists of a C `struct` with all the **attributes** of the class and associated C functions for all the **operations** (see also Application Note <a class="extern" target="_blank" href="https://www.state-machine.com/doc/AN_Simple_OOP_in_C.pdf">Simple Encapsulation and Inheritance in C</a>).

Additionally, the specific rendering of a class declaration in C depends on the file-type context. Specifically, if the `$declare${<Class>}` directive is used in a **header file** (`.h` file), the declaration generates function prototypes **without** the `static` keyword, as shown in the code generated by the directive `$declare${AOs::Ship}` for the class `AOs::Ship` shown in the screen shot above:

@code{.numbered}
/*${AOs::Ship} .............................................................*/
typedef struct {
/* protected: */
    QMActive super;

/* private: */
    uint8_t x;
    uint8_t y;
    uint8_t exp_ctr;
    uint16_t score;
} Ship;

/* protected: */
QState Ship_initial(Ship * const me, QEvt const * const e);
QState Ship_active  (Ship * const me, QEvt const * const e);
QState Ship_active_i(Ship * const me);
extern QMState const Ship_active_s;
QState Ship_parked  (Ship * const me, QEvt const * const e);
extern QMState const Ship_parked_s;
QState Ship_flying  (Ship * const me, QEvt const * const e);
QState Ship_flying_e(Ship * const me);
extern QMState const Ship_flying_s;
QState Ship_exploding  (Ship * const me, QEvt const * const e);
QState Ship_exploding_e(Ship * const me);
extern QMState const Ship_exploding_s;
@endcode

@note
A class with a @ref sm "State Machine", such as `Ship` in the example above, also contains functions and (`extern`) attributes for each @ref sm_state "State" of the *state machine*.


@section ce_declare_class_c-static Class Declaration in C (File Scope)
If the `$declare${<Class>}` directive is used in a **file scope** (inside a `.c` file), the declaration generates function prototypes **with** the `static` keyword, as shown in the code generated by the directive `$declare${AOs::Ship}` for the class `AOs::Ship` shown in the screen shot above:

@note
The use of the `static` keyword for all variables and functions declared at file scope is mandated by the <a class="extern" target="_blank" href="http://www.misra.org.uk">Motor Industry Software Reliability Association (<strong>MISRA</strong>)</a> guidelines.

@code{.numbered}
/*${AOs::Ship} .............................................................*/
typedef struct {
/* protected: */
    QMActive super;

/* private: */
    uint8_t x;
    uint8_t y;
    uint8_t exp_ctr;
    uint16_t score;
} Ship;

/* protected: */
static QState Ship_initial(Ship * const me, QEvt const * const e);
static QState Ship_active  (Ship * const me, QEvt const * const e);
static QState Ship_active_i(Ship * const me);
static QMState const Ship_active_s = {
    (QMState const *)0, /* superstate (top) */
    Q_STATE_CAST(&Ship_active),
    Q_ACTION_CAST(0), /* no entry action */
    Q_ACTION_CAST(0), /* no exit action */
    Q_ACTION_CAST(&Ship_active_i)
};
static QState Ship_parked  (Ship * const me, QEvt const * const e);
static QMState const Ship_parked_s = {
    &Ship_active_s, /* superstate */
    Q_STATE_CAST(&Ship_parked),
    Q_ACTION_CAST(0), /* no entry action */
    Q_ACTION_CAST(0), /* no exit action */
    Q_ACTION_CAST(0)  /* no intitial tran. */
};
static QState Ship_flying  (Ship * const me, QEvt const * const e);
static QState Ship_flying_e(Ship * const me);
static QMState const Ship_flying_s = {
    &Ship_active_s, /* superstate */
    Q_STATE_CAST(&Ship_flying),
    Q_ACTION_CAST(&Ship_flying_e),
    Q_ACTION_CAST(0), /* no exit action */
    Q_ACTION_CAST(0)  /* no intitial tran. */
};
static QState Ship_exploding  (Ship * const me, QEvt const * const e);
static QState Ship_exploding_e(Ship * const me);
static QMState const Ship_exploding_s = {
    &Ship_active_s, /* superstate */
    Q_STATE_CAST(&Ship_exploding),
    Q_ACTION_CAST(&Ship_exploding_e),
    Q_ACTION_CAST(0), /* no exit action */
    Q_ACTION_CAST(0)  /* no intitial tran. */
};
@endcode

@note
A class with a @ref sm "State Machine" based on the `QMsm` base class, such as `Ship` in the example above, contains also static and **const** "transition-tables" objects, which must be initialized at the point of declaration. In this case (file scope), the declarations of "transition-tables" are also definitions followed by initializers.


@section ce_declare_attr Free Attribute Declaration
The <strong>$declare${&lt;free-attribute&gt;}</strong> directive requests generating a **declaration** of the &lt;free-attribute&gt; specified between the parentheses. (Free attribute is a variable declared outside of any class in a package.) The following screen shot shows an example of a free attribute model item (in the @ref ui_explorer) and a `$declare${}` code-generation directive in a file template.

@image html ce_gen-attr.png "Example of a Free Attribute Declaration"

The following code snippet shows the <strong>C</strong> code generated by the `$declare${AOs::AO_Ship}` code-generation directive:

@code{.c}
extern QActive * const AO_Ship;
@endcode

The following code snippet shows the <strong>C++</strong> code generated by the `$declare${AOs::AO_Ship}` code-generation directive. Please note the __C++ namespace__ generated around the variable. This is because the enclosing package `AOs` provide the namespace `GAME`:

@code{.cpp}
namespace GAME {

extern QP::QActive * const AO_Ship;

} // namespace GAME
@endcode


@section ce_declare_oper Free Operation Declaration
The <strong>$declare${&lt;free-operation&gt;}</strong> directive requests generating a **declaration** of the &lt;free-operation&gt; specified between the parentheses. (Free operation is an operation declared outside of any class in a package). The following screen shot shows an example of a free operation model item (in the @ref ui_explorer) and a `$declare${}` code-generation directive in a file template.

@image html ce_gen-oper.png "Example of a Free Operation Declaration"

The following code snippet shows the <strong>C</strong> code generated by the `$declare${AOs::do_bitmaps_overlap}` code-generation directive:

@code{.numbered}
/*${AOs::do_bitmaps_overl~} ................................................*/
uint8_t do_bitmaps_overlap(
    uint8_t bmp_id1,
    uint8_t x1,
    uint8_t y1,
    uint8_t bmp_id2,
    uint8_t x2,
    uint8_t y2);
@endcode

The following code snippet shows the <strong>C++</strong> code generated by the `$declare${AOs::do_bitmaps_overlap}` code-generation directive. Please note the C++ namespace generated around the function. This is because the enclosing package `AOs` provides the namespace `GAME`:

@code{.numbered}
namespace GAME {

//${AOs::do_bitmaps_overl~} ..................................................
bool do_bitmaps_overlap(
    uint8_t bmp_id1,
    uint8_t x1,
    uint8_t y1,
    uint8_t bmp_id2,
    uint8_t x2,
    uint8_t y2);

} // namespace GAME
@endcode


@section ce_declare_package Package Declaration
The <strong>$declare${&lt;Package&gt;}</strong> directive requests generating a **recursive** declaration of all classes, free attributes, and free operations in the <strong>&lt;Package&gt;</strong>, as described in the sections above. (If a package contains other packages, these packages are recursively declared, as described in the first sentence.)

@note
The QM&trade; code generator honors the order of the items in the package (as viewed in the @ref ui_explorer).

@nav{ce_directive,ce_define}
*/
/*##########################################################################*/
/*! @page ce_define $define${}
@tableofcontents
@nav{ce_declare,ce_define1}

<p>The <strong>$define${}</strong> directive specifies a **recursive definition** of an element, such as:
</p>

- @ref bm_package "Package"
- @ref bm_class "Class"
- @ref bm_oper-class "Class Operation"
- @ref sm "State Machine"
- @ref sm_state "State"
- @ref bm_attr-free "Free Attribute"
- @ref bm_oper-free "Free Operation"


@nav{ce_declare,ce_define1}
*/
/*##########################################################################*/
/*! @page ce_define1 $define1${}
@tableofcontents
@nav{ce_define,ce_sm}

<p>The <strong>$define1${}</strong> directive specifies a **non-recursive definition** of an element, such as:
</p>

- @ref bm_package "Package"
- @ref bm_class "Class"
- @ref bm_oper-class "Class Operation"
- @ref sm "State Machine"
- @ref sm_state "State"
- @ref bm_attr-free "Free Attribute"
- @ref bm_oper-free "Free Operation"


@nav{ce_define,ce_sm}
*/
/*##########################################################################*/
/*! @page ce_sm Generating State Machine Code
@tableofcontents
@nav{ce_define1,ce_comment}

<p>In QM&trade; a State Machine can be associated only with a @ref bm_class "class" that is a direct or indirect subclass of the <a href="https://www.state-machine.com/products/qp/" target="_blank" class="extern">QP Framework</a> base class **QHsm**, shown in blue in the <a class="extern" target="_blank" href="http://en.wikipedia.org/wiki/Class_(computer_programming)">class diagram</a> @ref sm_super "below".
</p>

<div style="clear:both;"></div>
@anchor ce_sm_super
@image html qp_classes.gif "Main Classes in the QP/C and QP/C++ frameworks"

@note
QM&trade; supports **classes** and **inheritance** regardless of the target programming language, which currently can be either **C** or <strong>C++</strong>. The <a class="extern" target="_blank" href="https://www.state-machine.com/doc/AN_Simple_OOP_in_C.pdf">Application Note "Simple Object-Oriented Programming in C"</a> describes how the <a class="extern" target="_blank" href="https://www.state-machine.com/products/qp/">QP/C</a> and <a class="extern" target="_blank" href="https://www.state-machine.com/products/qp/">QP-nano</a> frameworks as well as the QM&trade; code generator implement *classes* and *inheritance* in portable **ANSI C**.


@section ce_sm_strategy Implementation Strategies
The <span style="background-color:#aaf;"> **QHsm** base class </span> (<span class="black">1</span>) provides the basic interface `init()` and `dispatch()` for initializing a state machine and for dispatching events to it, respectively. The specific implementations of the state machine interface in the <span style="background-color:#aaf;">QHsm</span> base class and its subclass <span style="background-color:#faa;">QMsm</span> (<span class="black">3</span>) determine the following **state machine implementation strategies** for code generation:


@subsection ce_qhsm_strategy The QHsm/QActive-Style Implementation Strategy
The <span style="background-color:#aaf;"> **QHsm** and **QActive** classes </span> from the @ref sm_class_qmsm "class diagram above" re-implement the basic state machine interface, and so they provide an alternative state machine @ref ce_sm "implementation strategy" that was originally designed for **manual coding** of HSMs, but now can also benefit from automatic code generation by QM&trade;

The older `QHsm/QActive`-style state machines are less efficient in time (CPU cycles) and space (e.g., stack usage) than the newer @ref sm_class_qmsm. This is because the `QHsm/QActive`-style implementation strategy requires discovering the *transition-sequences* (sequences of exit/entry/initial actions) at runtime as opposed to code-generation time.

@note
You should consider `QHsm/QActive`-style state machines only when you are still interested in **manual coding** or maintaining your state machines. (But then you will be working against the strictly @ref ab_special "forward-engineering nature" of QM&trade;)


@n

@subsection ce_qmsm_strategy QMsm/QMActive-Style Implementation Strategy
The <span style="background-color:#faa;"> **QMsm** and **QMActive** classes </span> from the @ref sm_class_qmsm "class diagram above" provide a very efficient state machine @ref ce_sm "implementation strategy", which requires the assistance of the QM&trade; tool (as an advanced "state machine compiler") to generate the complete *transition-sequences* at *code-generation* time. <span class="highlight">The resulting code is still **highly human-readable**, but is **not** suitable for manual coding or maintaining</span>.

The lab tests indicate that the `QMsm/QMActive`-style state machines can be about twice as fast as the `QHsm`-style state machines (considering only the state machine "housekeeping" code excluding any user-supplied actions, see the @ref sm_class_qhsm "next section" below). Additionally, the `QMsm/QMActive`-style state machines require less runtime support (smaller event processor) and use about 70% less of stack space for the `dispatch()` operation than `QHsm/QActive`-style state machines.

@note
The `QMsm/QMActive`-style state machines are <span class="highlight"> **highly recommended** </span> over the older `QHsm/QActive`-style state machines described @ref sm_class_qhsm "earlier". You should consider `QHsm/QActive`-style state machines only when you are still interested in **manual** coding or maintaining your state machines. (But then you will be working against the strictly @ref ab_special "forward-engineering nature" of QM&trade;)

@attention
Starting from version 4, QM&trade; requires a @ref ui_license_cert "QM license certificate" to generate the @ref sm_class_qmsm "QMsm state machine implementation strategy". If you don't have a valid license, the QM Code Generator will report the following licensing errors:
@image html error_l001.png


@section ce_sm_act Action Code


@subsection ce_sm_act_me Accessing Attributes (me-&gt; Pointer)


@subsection ce_sm_act_e Accessing Event Parameters (e-&gt; Pointer)


@nav{ce_define1,ce_comment}
*/
/*##########################################################################*/
/*! @page ce_comment Generating Comments
@tableofcontents
@nav{ce_sm,ce_cond}

<p>Even though the code generated by QM&trade; is not intended to be edited manually outside QM&trade;, it still needs to be understood and debugged using a traditional source-level debuggers.
</p>

Also, some engineering organizations require all code, including auto-generated code, to comply with the internal *coding standards*. Such standards often dictate very specific **commenting style**, like provision of special file comments, function comments, variable comments, etc.

To enhance the readability of the generated code and to meet the special commenting style requirements, QM&trade; can emit several kinds of various **comments**, all described in the following sections.

<div style="clear:both;"></div>


@section ce_comment-file Top-Level File Comment
At the top of each @ref ce_file "generated file", QM&trade; generates a **top-level comment**, which has two purposes:

1. to remind the reader right away that this file is generated automatically and should **not** be changed manually, as any such changes will be lost when the file is re-generated from the model.

2. to inform the reader about the licensing terms applying to the generated code, which are the same as the underlying QP framework, as explained in the section @ref ab_gen_code "Licensing the Generated Code".


@note
If you wish to add some additional comment at the top of your file, you can always put such a comment in the original @ref ce_file "file-item", which QM&trade; will then copy over to the file on disk immediately **after** the top-level comment described here.


@subsection ce_comment_gpl QP Used Under GPL
The following snippet of code shows the top-level file comment in the case when the underlying QP framework is used under the <a class="extern" target="_blank" href="https://state-machine.com/licensing/#Open">open-source GPL license</a>:

@code{.c}
/*.$file${.::file.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: test1.qm
* File:  ./file.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*.$endhead${.::file.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
@endcode

@sa @ref ui_license-open "Code Generation License Dialog Box--Open Source"


@subsection ce_comment_commercial QP Used Under a Commercial License
The following snippet of C++ code shows the top-level file comment in the case when the underlying QP framework is used under a <a class="extern" target="_blank" href="https://state-machine.com/licensing/#Commercial">commercial QP</a> license (NOTE: In C++, the generated comments use the C++ comment style: `//...`, while in C, the C comment stye: /`*...*`/):

@code{.cpp}
//.$file${.::test2.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: test2.qm
// File:  ./file.cpp
//
// This code has been generated by QM tool (see state-machine.com/qm).
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This code is covered by the following commercial QP license:
// License #   : QPCPP-SP-141224A
// Issued to   : Bamboozle Technologies, Inc.
// Framework(s): qpcpp
// Support ends: 2015-12-24
// Product(s)  :
// eGizmo Shuffle 2nd Generation
//
//.$endhead${.::test2.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
@endcode

@sa @ref ui_license-closed "Code Generation License Dialog Box--Closed Source"


@section ce_comment-doc Generating Comments from Documentation
QM&trade; allows you to generate comments from the **documentation property** that is available in many model items, such as @ref bm_class "classes", @ref bm_attr "attributes", @ref bm_oper-class "operations", and @ref sm_state "states".

@note
The feature of generating comments from documentation has been primarily designed to help organizations comply with the specific commenting style imposed by their internal standards.


The following screen shot shows an example of the *documentation property* that generates comments. Specifically, the example generates a comment with the @ref ce_declare "declaration" of the class as well another comment with the @ref ce_define "definition" of the class.

@image html ce_comment-doc.png "Comments in the Documentation Property"

The QM code generator uses the following algorithm to generate comments from the *documentation property*:

1. The documentation text is searched for a comment, whereas both the C-style comments (/`*...*`/) and C++-style comments (`//`) are allowed. If no comment is found, the documentation property generates **no** comments. (NOTE: Any comments in the *documentation property* are clearly indicated by **syntax highlighting**);

2. The first comment found is considered to pertain to the **declaration** and is generated with the @ref ce_declare "declaration" of the model item;

3. The second comment found is considered to pertain to the **definition** and is generated with the @ref ce_define "definition"  of the model item;

4. If only one comment is found, the comment is considered to pertain to both @ref ce_declare "declaration" and @ref ce_define "definition" of the model item. In this case this (same) comment is generated with the *declaration* and with the *definition* of the model item.

5. All other text in the documentation property preceding or following comments has no implications for code generation. Such text is considered internal model documentation.

@note
As illustrated in the screen shot above, the comments in the *documentation property* can contain special markup, such as <a class="extern" target="_blank" href="http://www.doxygen.org">Doxygen</a>, <a class="extern" target="_blank" href="http://docpp.sourceforge.net/">Doc++</a>, <a class="extern" target="_blank" href="https://sourceforge.net/projects/robodoc">RoboDoc</a>, etc.


@section ce_comment-link Model-Link Comments
QM&trade; generates also comments that contain the **model-links**. These **model-link comments** have a generic form: /`* ${<fully-qualified-name>} *`/, where `<fully-qualified-name>` is the @ref bm_fq-name "Fully-Qualified Item Name" of the referenced item. The following code snippet provides several examples of **model-reference comments** at lines [1-4]:

@code{.c}
[1]  /* ${AOs::Missile::SM::flying} */
     static QState Missile_flying(Missile * const me, QEvt const * const e) {
         QState status_;
         switch (e->sig) {
[2]          /* ${AOs::Missile::SM::flying::TIME_TICK} */
             case TIME_TICK_SIG: {
[3]              /* ${AOs::Missile::SM::flying::TIME_TICK::[me->x+GAME_MI~]} */
                 if (me->x + GAME_MISSILE_SPEED_X < GAME_SCREEN_WIDTH) {
   :                 ObjectImageEvt *oie;
                     me->x += GAME_MISSILE_SPEED_X;
                     /*tell the Tunnel to draw the Missile and test for wall hits*/
                     oie = Q_NEW(ObjectImageEvt, MISSILE_IMG_SIG);
                     oie->x   = me->x;
                     oie->y   = me->y;
                     oie->bmp = MISSILE_BMP;
                     QACTIVE_POST(AO_Tunnel, (QEvt *)oie, me);
                     status_ = QM_HANDLED();
                 }
[4]              /* ${AOs::Missile::SM::flying::TIME_TICK::[else]} */
                 else {
                     static QMTranActTable const tatbl_ = { /* transition-action table */
                         &Missile_armed_s,
                         {
                             Q_ACTION_CAST(0) /* zero terminator */
                         }
                     };
                     status_ = QM_TRAN(&tatbl_);
                 }
                 break;
             }
         . . .
@endcode

The **model-link comments** allow you to quickly open the linked model item as the @ref ui_curr_item "Current Item" in QM&trade; To do so, you only need to:

1. Select a piece of code containing the desired **model-link comment** and copy it into the Clipboard (Ctrl-C), which you can do from virtually any code editor or debugger.

2. Next, click on QM&trade; tool and click the <span class="img paste_link">button</span> or just press <span class="button"><strong>F5</strong></span> (see @ref ui_toolbar_edit and @ref ui_menu_edit)


@section ce_comment-div Divider Comments
Finally, to improve readability of the generated code, QM&trade; generates **divider comments** to visually separate various sections of code, as illustrated in the following snippet of generated code (lines [1-3]):

@code{.c}
[1]  /*${AOs::Missile_ctor} .....................................................*/
     void Missile_ctor(void) {
         Missile *me = &l_missile;
         QMActive_ctor(&me->super, Q_STATE_CAST(&Missile_initial));
     }
[2]  /*${AOs::Missile} ..........................................................*/
[3]  /*${AOs::Missile::SM} ......................................................*/
     static QState Missile_initial(Missile * const me, QEvt const * const e) {
         static QMTranActTable const tatbl_ = { /* transition-action table */
         . . .
@endcode

The *divider comments* often contain the @ref bm_fq-name "Fully-Qualified Item Name" of the model item that follows, so you can use the *divider comments* to quickly open the referenced model item as the @ref ui_curr_item "Current Item" in QM&trade;, as described in the previous section @ref ce_comment-link.

@nav{ce_sm,ce_cond}
*/
/*##########################################################################*/
/*! @page ce_cond Conditional Compilation
@tableofcontents
@nav{ce_comment,ce_qmc}

<p>Often, the models created with QM are intended for entire families of related products (product lines), as opposed to a single end-product only. The designers of such product lines often find that big pieces of the model, such as state machines, can be similar in all individual products, except for some parts that vary.
</p>

One popular way to manage the variations at the C/C++ code level is through **conditional compilation**, meaning that blocks of code are surrounded by the preprocessor statements #`if<expr>` / #`endif`  and are actually compiled only when the preprocessor expression `<expr>` evaluates to true at compile time.

QM inherently supports inserting any user code into @ref ce_file "file-templates", which means that you can very easily surround blocks of code of your choice (including the @ref ce_directive ) with conditional compilation statements.

However, to achieve a fine-granularity conditional compilation **inside** classes you need to use the special support for conditional compilation built-into QM. The conditional compilation is supported for the following model items:

- @ref bm_attr "attributes" (class attributes and free attributes)
- operations (@ref bm_oper-class "class operations" and @ref bm_oper-free "free operations")
- @ref sm_state "states" (composite states and leaf states)
- @ref sm_tran "transitions" (regular transitions, internal transitions, transitions with guards, and `CATCH_ALL` transitions).


@note
The conditional compilation is supported for all QP framework types (`qpc`, `qpcpp`, and `qpn`) as well as all state machine types (subclasses of `QMsm` and `QHsm` base classes in QP5).


@section ce_cond_apply Applying Conditional Compilation
To mark a model item as conditionally compiled, append a <span class="highlight">question mark (`?`)</span> followed by the preprocessor expression to the **name** of the attribute, state, or the transition in the @ref ui_prop. The following two screen shots provide examples for a conditional state and conditional transition, respectively. The highlighted text after the state name and transition trigger, respectively, corresponds to the pre-processor expression.

@image html ce_cond_state_prop.png "Setting the Name Property of a Conditionally Compiled State"
@n
@image html ce_cond_tran_prop.png "Setting the Name Property of a Conditionally Compiled Transition"


@subsection ce_cond_expr Pre-processor Expression Syntax
The conditional expression that you add to the name property of a state or transition can be any valid expression accepted by the C/C++ pre-processor (excluding the `?`, obviously).

For example, a conditional compilation expression `?def FOO_BAR` will lead to the generation of the following pre-processor statements around a @ref ce_declare "declaration" or @ref ce_define "definition" of a state:

@code{.numbered}
#ifdef FOO_BAR
    //. . .
#endif /* def FOO_BAR */
@endcode

@note
Please note that the QM code generator specifically does **not** append any spaces after the #`if`, so that statements of the form #`ifdef FOO_BAR` and #`ifundef FOO_BAR` can be easily generated from the conditions `?def FOO_BAR` and `?undef FOO_BAR`, respectively.

However, your pre-processor expressions might be also more complex and might include logical operators `&&`, `||`, etc. For example, the condition `? (defined FOO_BAR) && (VERSION >= 531)` will lead to the generation of the following pre-processor statements:

@code{.numbered}
#if (defined FOO_BAR) && (VERSION >= 531)
    //. . .
#endif /*  (defined FOO_BAR) && (VERSION >= 531) */
@endcode


@subsection ce_cond_render Rendering Conditional States/Transitions
As shown in the screen shots below, the QM&trade; tool will give you a visual indication by displaying the question mark (`?`) in front of the state name or the transition trigger in the @ref sm "State Diagram" as well as in the @ref ui_explorer :

@image html ce_cond_state.png "Rendering of a Conditionally-Compiled State"
@n
@image html ce_cond_tran.png "Rendering of a Conditionally-Compiled Transition"


@subsection ce_cond_check Conditional Compilation and Model Correctness
The QM&trade; code generator applies the conditional compilation **consistently** and in a way that most developers should find **intuitive**.

For example, for a conditionally-compiled state, both the state @ref ce_declare "declaration" and state @ref ce_define "definition" will be surrounded by the corresponding #`if<expr>` / #`endif` statements. Similarly, all substates of a conditionally-compiled state will be surrounded by the same  #`if<expr>`/#`endif` statements as the superstate. The QM code generator will even correctly nest the #`if`/#`endif` statements for nested states, as one would expect. (NOTE: The following sub-sections describe how conditional compilation is applied in various special cases.)

@attention
However, the QM&trade; code generator is limited in that it does not "know" the settings of the pre-processor macros used for the conditional expressions. Consequently, QM can **not** check the completeness of a whole state-machine with some states or transitions conditionally-compiled. For example, the QM code generator will **not** report errors for transitions targeting conditionally-compiled states, even though such states might be "compiled out" in the actual code. In most such cases, the compilation of the code will fail (so you will **know** that your model is inconsistent), but avoiding such inconsistencies in the model is considered the responsibility of the developer (**you**), not the QM&trade; tool.


@section ce_cond_state Conditional States
This section describes the special cases of conditionally-compiled states.


@subsection ce_cond_state_nest Nesting Conditional States
If both a superstate and some of its substates are conditionally compiled (each with their own conditional expressions), the QM code generator **will** correctly **nest** the #`if`/#`endif` statements around the substates.

@image html ce_cond_nest.png "Nested Conditional States"

For example, if a superstate `state1` with a condition `?def FOO_BAR` has a substate `state3` with a condition `?(VERSION > 531)`, QM will generate the following conditional compilation statements for `state1` and `state3`.

@code{.numbered}
typedef struct {
/* protected: */
    QMsm super;
/* private state histories */

#ifdef FOO_BAR
    QMState const *his_state1;
#endif /* def FOO_BAR */

} Test_QMsm;


#ifdef FOO_BAR
#if(VERSION > 531)
    // declaration or definition of state3
#endif /* (VERSION > 531) */
#endif /* def FOO_BAR */
@endcode


@subsection ce_cond_state_hist Conditional States with History
If a conditionally compiled state has a @ref sm_hist "history", the QM code generator **will** correctly surround the @ref ce_declare "declaration" and the initialization of the state history variable. This will prevent allocating space and thus wasting memory (RAM) for the history attribute, in case the corresponding state is "compiled out".

@image html ce_cond_hist.png "Conditional State with History"

For example, if `state1` with a condition `?def FOO_BAR` has a history connector, QM will generate the following conditional compilation statements around the @ref ce_declare "declaration" and initialization of the `his_state1` history attribute.

@code{.numbered}
/*${AOs::Test_QMsm} .......................................................*/
typedef struct {
/* protected: */
    QMsm super;
/* private state histories */

#ifdef FOO_BAR
    QMState const *his_state1;
#endif /* def FOO_BAR */

} Test_QMsm;


/*${AOs::Test_QMsm::SM} ...................................................*/
static QState Test_QMsm_initial(Test_QMsm * const me, QEvt const * const e) {
    // . . .

#ifdef FOO_BAR
    me->his_state1 = &Test_QMsm_state3_s;
#endif /* def FOO_BAR */

    return QM_TRAN_INIT(&tatbl_);
}
@endcode


@section ce_cond_tran Conditional Transitions
A conditional compilation condition appended to the trigger name works for all @ref sm_tran "transition types" supported by QM, including regular transitions, internal transitions, transitions with guards, multi-trigger transitions, and `CATCH_ALL` transitions. The following sub-sections describe the special cases for conditionally-compiled transitions.

Due to the way transitions are implemented in QP, there is no *declaration* of transition, so the conditional compilation applies only to the definition of a transition inside a state-handler function. The following snippet of code shows the conditional transition `TRIG2` with the condition `? (defined FOO_BAR) && (VERSION >= 531)` at line 6:

@code{.numbered}
/* ${AOs::Test_QMsm::SM::state1} */
static QState Test_QMsm_state1(Test_QMsm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {

#if (defined FOO_BAR) && (VERSION >= 531)
        /* ${AOs::Test_QMsm::SM::state1::TRIG2} */
        case TRIG2_SIG: {
            action2();
            // action associated with TRAN2
            break;
        }
#endif /*  (defined FOO_BAR) && (VERSION >= 531) */

        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    (void)me; /* avoid compiler warning in case 'me' is not used */
    return status_;
}
@endcode

@note
Conditionally-compiled transitions can be attached to conditionally-compiled states. In that case the #`if`/#`endif` preprocessor statements will naturally nest, which will produce the expected result. (A transition will only be "compiled in" when both the conditional expression for the state as well as the actual conditional expression for the transition evaluate to true.)


@subsection ce_cond_tran_multi Multi-Trigger Conditional Transitions
A multi-trigger transition is a transition labeled with a (comma-separated) list of triggers, any one of which can trigger the transition. The conditional compilation works for this type of transition as well. In that case, you simply append the list of triggers with the question-mark (`?`) and the pre-processor expression. The following screen shot illustrates the situation:

@image html ce_cond_multi.png "Multi-Trigger Conditional Transition"


@subsection ce_cond_tran_catch CATCH_ALL Conditional Transitions
The special **CATCH_ALL** transition is triggered by any not-explicitly handled trigger by a given state (so it "catches" all triggers). The conditional compilation works for this type of transition as well. In that case, you simply append the special `CATCH_ALL` pre-defined trigger with the question-mark (`?`) and the pre-processor expression. The following screen shot illustrates the situation:

@image html ce_cond_catch.png "CATCH_ALL Conditional Transition"


Because CATCH_ALL transitions are implemented in QP, the preprocessor #`if` statement also has the #`else` branch in this example, so that there is no "catch all" behavior when the transition is "compiled out". The following code snippet illustrates the conditional transition in a `QMsm` sub-class (please note the #`else` conditional branch):


@code{.c}
/* ${AOs::Test_QMsm::SM::state1} */
static QState Test_QMsm_state1(Test_QMsm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        // triggers ...
        default: {

#ifdef FOO
            /* ${AOs::Test_QMsm::SM::state0::CATCH_ALL} */
            static struct {
                QMState const *target;
                QActionHandler act[3];
            } const tatbl_ = { /* transition-action table */
                &Test_QMsm_state1_s, /* target state */
                {
                    Q_ACTION_CAST(&Test_QMsm_state0_x), /* exit */
                    Q_ACTION_CAST(&Test_QMsm_state1_e), /* entry */
                    Q_ACTION_CAST(0) /* zero terminator */
                }
            };
            action1();
            status_ = QM_TRAN(&tatbl_);
#else
            status_ = QM_SUPER();
#endif /* def FOO */

            break;
        }
    }
    return status_;
}
@endcode
@n

The following code snippet illustrates the conditional transition in a `QHsm` sub-class (please note the #`else` conditional branch):

@code{.c}
/*${AOs::Test_QHsm::SM::state1} ............................................*/
static QState Test_QHsm_state1(Test_QHsm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::Test_QHsm::SM::state1} */
        case Q_ENTRY_SIG: {
            entry1();
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Test_QHsm::SM::state1} */
        case Q_EXIT_SIG: {
            exit1();
            status_ = Q_HANDLED();
            break;
        }

        // triggers ...

        default: {

#ifdef FOO
            /* ${AOs::Test_QHsm::SM::state1::CATCH_ALL} */
            if (e->sig < Q_USER_SIG) {
                status_ = Q_SUPER(&QHsm_top);
            }
            else {
                action1();
                status_ = Q_TRAN(&Test_QHsm_state2);
            }
#else
            status_ = Q_SUPER(&QHsm_top);
#endif /* def FOO */

            break;
        }
    }
    return status_;
}
@endcode
@n

@nav{ce_comment,ce_qmc}
*/
/*##########################################################################*/
/*! @page ce_qmc QM Compiler (qmc)
@tableofcontents
@nav{ce_cond,history}

<p>The @ref gs_install_folder "QM&trade; installation folder" contains the **command-line** utility called <span class="highlight"><strong>qmc</strong></span> (QM Compiler), which can generate code from a given @ref ui_model_file "QM model file". The `qmc` utility allows you to incorporate the code generation step into an **automated build process**, such as `Makefiles`, build scripts, or extra pre-compile steps in project files.
</p>

By design, the `qmc` utility generates identical code as the QM&trade; graphical tool. In particular, `qmc` is aware of the @ref ui_session_file "QM session file" and applies the same QP licensing terms as QM&trade; (see also @ref ce_comment "generating comments").

@attention
The `qmc` utility has been specifically designed to run on "headless" servers, where GUI libraries are not installed.


<div style="clear:both;"></div>


@section ce_qmc_command QMC Command-Line Arguments
QMC supports the following command-line options:

@verbatim
qmc 5.0.4 (c) Quantum Leaps. https://www.state-machine.com/qm

Usage: qmc <model-file> [-h][-c [item]]
or:    qmc [-h][-c [item]] [--] <model-file>

Notes:
The argument <model-file> must be provided
The option -c [item] might be repeated multiple times
[item] is the fully-qualified model item name, e.g., ${foo::bar}

Examples:
qmc my_model.qm (generate code for entire model "my_model.qm")
qmc xyz\my_model.qm (generate code for entire model "xyz\my_model.qm")
qmc D:\xyz\my_model.qm (generate code for entire model "D:\xyz\my_model.qm")
qmc -c ${pkgA} my_model.qm (generate code for item ${pkgA})
qmc -c -- my_model.qm (generate code for entire model "my_model.qm")
qmc my_model.qm -c ${pkgA} (generate code for item ${pkgA})
qmc my_model.qm -c ${pkgA} -c${pkgB::.} (generate code for item ${pkgA} and ${pkgB::.})
qmc my_model.qm -c ${.::main.c} (generate code for item ${.::main.c})
@endverbatim

where `<qm-model-file>` stands for the @ref ui_model_file "QM model file" to process. The `<qm-model-file>` can contain the whole absolute or relative **path** to the QM model file.


@section ce_qmc_win Invoking qmc on Windows
On Windows, the QMC executable is located in the `<qm>/bin/` directory, where `<qm>` denotes the QM installation directory.

@verbatim
c:\qp\qm\bin\qmc.exe <qm-model-file>
@endverbatim


@section ce_qmc_linux Invoking qmc on Linux
On Linux, you invoke `qmc` by means of the **shell script** `qmc.sh`, which is  located in the `<qm>/bin/` directory, where `<qm>` denotes the directory, in which you have installed QM. Assuming that you have installed QM in `/home/<user>/qp/qm`, you can invoke the `qmc` as follows:

@verbatim
/home/<user>/qp/bin/qm.sh <qm-model-file>
@endverbatim

where `<qm-model-file>` stands for the @ref ui_model_file "QM model file" to process. The `<qm-model-file>` can contain the whole absolute or relative **path** to the QM model file.


@section ce_qmc_mac Invoking qmc on MacOS
On MacOS, the `qmc` executable is located in the same bundle as the QM graphical modeling tool. Assuming that you have installed QM into the `/Applications/` folder, you can invoke the `qmc` as follows:

@verbatim
/Applications/qm.app/Contents/MacOS/qmc <qm-model-file>
@endverbatim

where `<qm-model-file>` stands for the @ref ui_model_file "QM model file" to process. The `<qm-model-file>` can contain the whole absolute or relative **path** to the QM model file.

@nav{ce_cond,history}
*/

